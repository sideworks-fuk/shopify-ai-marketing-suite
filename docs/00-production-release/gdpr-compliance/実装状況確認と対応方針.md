### 現状の実装状況（要点）
- 必須Webhook4種を実装済み（HMAC検証・必須ヘッダ検証・即時200応答・冪等化・監査ログ）
  - app/uninstalled
  - customers/redact
  - shop/redact
  - customers/data_request
- HMAC検証（固定時間比較）、ボディ再読込、サイズ上限チェックを実装
```426:475:backend/ShopifyAnalyticsApi/Controllers/WebhookController.cs
private async Task<bool> VerifyWebhookRequest()
{
    // ... 省略 ...
    using var hmac = new HMACSHA256(Encoding.UTF8.GetBytes(secret));
    var computedHashBytes = hmac.ComputeHash(Encoding.UTF8.GetBytes(body));
    // 受信値をBase64デコード
    // ...
    // 固定時間比較で検証
    return CryptographicOperations.FixedTimeEquals(computedHashBytes, receivedHmacBytes);
}
```
- トピック許可リストと必須ヘッダ検証を実装
```893:931:backend/ShopifyAnalyticsApi/Controllers/WebhookController.cs
private bool ValidateRequiredHeaders(string expectedTopic, out string topic, out string shopDomain, out string webhookId)
{
    // ... 省略 ...
    var allowed = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
    {
        "app/uninstalled","customers/redact","shop/redact",
        "customers/data_request","app_subscriptions/update","app_subscriptions/cancel"
    };
    // ... 省略 ...
    if (!allowed.Contains(topic)) { return false; }
    if (!string.Equals(topic, expectedTopic, StringComparison.OrdinalIgnoreCase)) { return false; }
    return true;
}
```
- 即時200応答（5秒要件対策）と非同期処理パターンを採用
```104:115:backend/ShopifyAnalyticsApi/Controllers/WebhookController.cs
// 即座に200 OKを返す（5秒ルール）
started.Stop();
_logger.LogInformation("app/uninstalled ... Result={Result} LatencyMs={Latency}", "accepted", started.ElapsedMilliseconds, ...);
return Ok();
```
- Webhookイベントの冪等化と記録（IdempotencyKey生成・重複抑止）
```836:886:backend/ShopifyAnalyticsApi/Controllers/WebhookController.cs
private async Task LogWebhookEvent(string shopDomain, string topic, object payload)
{
    // ... 省略 ...
    var idempotencyKey = GenerateWebhookIdempotencyKey(shopDomain, topic, serialized);
    var exists = await _context.WebhookEvents.AnyAsync(w => w.IdempotencyKey == idempotencyKey);
    if (exists) { /* 既存 */ return; }
    // WebhookEventsに記録
    _context.Add(webhookEvent);
    await _context.SaveChangesAsync();
}
```
- Hangfireダッシュボード有効化とGDPR Pending処理の定期ジョブ登録
```311:323:backend/ShopifyAnalyticsApi/Program.cs
app.UseHangfireDashboard("/hangfire", new Hangfire.DashboardOptions { /* 認可等 */ });
RecurringJob.AddOrUpdate<GdprProcessingJob>(
    "gdpr-process-pending",
    job => job.ProcessPendingRequests(),
    "*/5 * * * *");
```

### 課題・ギャップ（要修正）
- 本番の「削除スケジューリング」が一部TODOのまま
```576:586:backend/ShopifyAnalyticsApi/Controllers/WebhookController.cs
// 開発環境では即座に削除（本番環境ではHangfireでスケジュールすべき）
if (Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT") == "Development" || daysToDelete == 0)
{
    await _dataCleanupService.DeleteStoreDataAsync(shopDomain);
}
else
{
    // TODO: 本番環境ではHangfireでスケジュール
    _logger.LogInformation("本番環境では{Days}日後にデータを削除します. Shop: {Shop}", daysToDelete, shopDomain);
}
```
- 監査テーブルのユニーク制約（IdempotencyKey）のDB側担保が未確認（コード側は事前Existsチェックのみ）
- 仕様書のルート表記と実装ルートの軽微な差（`/api/webhooks/...` vs `/api/webhook/...`）は運用上問題なしだが、ドキュメント整合は要更新
- 期限管理（30日/90日/10日）と通知・証跡の自動化レベルは要点検（実装計画書のSLA準拠）

### 当初設計・計画の妥当性（要点）
- 設計方針（即時200応答＋非同期、HMAC固定時間比較、冪等化、監査ログ、Hangfire処理）はShopify/GDPR要件に適合。問題なし
- 仕様書のDBスキーマ（GDPRRequests・RetentionPolicies等）は計画に妥当。実装が未適用の場合は適用推奨
- 運用（監視/アラート/KPI）は仕様書通りで妥当。App Insights連携のメトリクス可視化を実測で確認推奨

### 今後の作業（優先度順）
1) 本番スケジューリングの実装完了
- 対象: `ScheduleDataDeletion`/`ScheduleCustomerDataDeletion`/`ScheduleShopDataDeletion` の「TODO」をHangfireジョブ登録に置換
- 期限値（48h/30d/90d）をジョブ引数に付与し、`GdprProcessingJob`側で期限・状態遷移を管理

2) 監査テーブルの一意制約追加
- `WebhookEvents.IdempotencyKey` にユニークインデックスを付与（競合時もDBで一意性担保）

3) E2E検証（Staging）
- 4種WebhookのHMAC成功/失敗、重複配信、順不同、ペイロード上限、5秒応答の実測証跡（ログ/動画/スクショ）
- `app/uninstalled`でサブスク取消＋削除スケジュール登録が確実に残ること

4) 期限SLAの自動化
- GDPRRequests（pending→processing→completed）と期限超過検知・通知をHangfireで定期評価
- 期限前アラート/超過アラートをApp Insights/Slack等に連携

5) ドキュメント整合と運用手順
- 仕様書のルート表記更新（webhook(s)の統一）
- テスト手順の最新化（.http / curl例、HMAC計算手順、AI/KQLクエリ）

6) PIIログガード
- 監査ログに個人情報を出さないことの再点検（現状LogInformationのパラメータを確認し、Email/住所等は含めない）

必要があれば、上記(1)(2)の具体コード差分案も提示します（Hangfire登録箇所・ユニークインデックスDDL）。


# 追記（進め方） - 2025-10-06 13:46:38 JST

## ゴール（完了条件）
- 4種WebhookのStaging E2E証跡（HMAC成功/失敗、重複、順不同、5秒応答、サイズ上限）が揃っている
- 本番用削除スケジューリング（48h/30d/90d）がHangfireで運用化済み（手動実行手順含む）
- `WebhookEvents.IdempotencyKey` にユニークインデックスを付与済み
- 仕様書/手順書を現行実装に整合（ルート表記、.http、KQL、運用ガイド）

## 実行順序（MVP最短）
1. 本番スケジューリングの実装完了（Hangfireジョブ実装/登録）
2. DBユニークインデックス追加（IdempotencyKey）
3. Staging E2E検証（.http + 実運用ログ取得）
4. ドキュメント整合更新（仕様/手順/監視）

## タスク一覧（担当/所要目安）
- T1: Hangfireジョブ実装（削除/エクスポート）［Takashi｜0.5d］
- T2: ジョブ登録フロー（Program.cs or 専用登録サービス）［Takashi｜0.25d］
- T3: ユニークインデックスDDL適用（Stg→Prod計画含む）［Takashi｜0.25d］
- T4: E2E検証スクリプト整備（.http, curl, HMAC計算）［Kenji｜0.25d］
- T5: 検証実施と証跡採取（ログ/動画/スクショ）［全員｜0.5d］
- T6: ドキュメント更新（仕様/手順/監視/KQL）［Kenji｜0.25d］

## テスト計画（Staging）
- 正常系: 4種Webhookに対し200/5秒以内、履歴記録、スケジュール登録
- エラー系: 不正HMAC/未許可トピック/ヘッダ不足/サイズ超過
- 冪等: 同一WebhookId/created_atで重複送信→重複記録なし
- スケジューリング: 登録→期限到来前後の状態遷移を確認

## 証跡の取り方
- Application Insights（クエリテンプレ/KQL）
- Hangfireダッシュボードのジョブ履歴スクショ
- Web APIログ（相関ID/RequestIdを含む連鎖確認）
- .http 実行履歴とレスポンス保存

## リスクと対策
- スケジュール未実行: ジョブのレジューム/再実行手順をRunbook化
- PII混入: ログフィルタの再点検（メール/住所等は出力禁止）
- 時間要件逸脱: 応答を先に返し、非同期処理に徹底分離


# 追記（プロジェクト全体との整合性確認） - 2025-10-06 12:52 JST

## プロジェクト管理ドキュメントとの相違確認

### 実装状況の認識相違
プロジェクト管理ドキュメント（PM-001～004）を精査した結果、以下の重要な認識相違を発見：

| 項目 | PM文書の認識 | 実際の状況 | ギャップ |
|------|------------|-----------|---------|
| GDPR Webhook実装 | 🔴 未着手（FR-007） | ✅ 基本実装完了 | 認識更新必要 |
| HMAC検証 | 未実装扱い | ✅ 実装済み | - |
| 即時200応答 | 未実装扱い | ✅ 実装済み | - |
| 冪等化処理 | 未実装扱い | ✅ 実装済み | - |
| Hangfire統合 | 未実装扱い | ✅ 実装済み | - |
| 本番削除スケジュール | - | 🟡 TODO残存 | 正しく認識必要 |

### 申請に向けた真の優先事項

#### 🔴 最優先（申請ブロッカー）
1. **本番削除スケジューリングの完了**
   - 対象: `WebhookController.cs:576-586`のTODO部分
   - Hangfireジョブ登録の実装
   - 見積: 0.5日（Takashi）
   - **申請却下リスク**: 高

2. **環境変数設定**
   - `SHOPIFY_FRONTEND_BASEURL`の設定
   - Azure App Serviceでの設定確認
   - 見積: 30分（Kenji）
   - **申請却下リスク**: 中（OAuth動作不良）

3. **E2E検証の実施**
   - Staging環境での4種Webhook動作確認
   - 証跡採取（ログ、スクリーンショット）
   - 見積: 0.5日（全員）
   - **申請却下リスク**: 中（未検証での不具合）

#### 🟡 申請前推奨
4. **DBユニーク制約追加**
   - `WebhookEvents.IdempotencyKey`
   - 見積: 0.25日（Takashi）
   - **申請却下リスク**: 低（コード側で対応済み）

5. **申請素材準備**
   - アイコン（1024x1024px）、スクリーンショット、説明文
   - 見積: 1-2日
   - **申請却下リスク**: 高（素材不足は即却下）

### 実装完了度の正確な評価

| カテゴリ | 完了度 | 残作業 |
|---------|--------|--------|
| **GDPR基本実装** | 95% | 本番スケジューリングのみ |
| **認証・セキュリティ** | 100% | - |
| **課金システム** | 90% | 最終確認のみ |
| **フロントエンド** | 80% | モック画面の実装化 |
| **テスト** | 20% | E2E検証必須 |
| **申請素材** | 0% | 全て作成必要 |

### スケジュール修正案

```
2025-10-06（本日）:
  - 環境変数設定 [30分]
  - 本番スケジューリング実装着手 [開始]

2025-10-07:
  - 本番スケジューリング完了 [午前]
  - DBユニーク制約追加 [午後]
  - E2E検証準備 [午後]

2025-10-08:
  - E2E検証実施 [全日]
  - 申請素材作成開始 [並行]

2025-10-09:
  - 検証結果確認・修正
  - 申請素材完成

2025-10-10:
  - 最終確認
  - Shopify申請提出
```

### 結論
**GDPR対応は想定以上に進んでおり、申請は現実的に可能**。ただし：
1. 本番削除スケジューリングは必須実装（0.5日で完了可能）
2. E2E検証は省略不可（証跡必須）
3. 申請素材準備を並行で進める必要あり

PM文書との認識ギャップを解消し、真の残タスクに集中することで、**今週中の申請提出が可能**。


# 追記（残作業詳細：ソース確認ベース） - 2025-10-06 13:56:27 JST

## 1) 本番削除スケジューリングの実装（必須）
- 現状: Webhook側は「開発環境は即時削除、本番はTODOでログのみ」
```576:586:backend/ShopifyAnalyticsApi/Controllers/WebhookController.cs
// 開発環境では即座に削除（本番環境ではHangfireでスケジュールすべき）
if (Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT") == "Development" || daysToDelete == 0)
{
    await _dataCleanupService.DeleteStoreDataAsync(shopDomain);
}
else
{
    // TODO: 本番環境ではHangfireでスケジュール
    _logger.LogInformation("本番環境では{Days}日後にデータを削除します. Shop: {Shop}", daysToDelete, shopDomain);
}
```
- 実施内容:
  - Hangfireで「遅延ジョブ」登録（Shop/Customer/Shop全体の3種）
  - `GdprProcessingJob`はpending処理を実装済み（*/5分）。本件は「期限付き単発ジョブ」を追加
  - 目安: 0.5日（Takashi）

## 2) WebhookEvents.IdempotencyKey のDBユニーク制約追加
- 現状: アプリ側でExistsチェックは実装済み、DB側ユニークインデックス未確認
```836:856:backend/ShopifyAnalyticsApi/Controllers/WebhookController.cs
var idempotencyKey = GenerateWebhookIdempotencyKey(shopDomain, topic, serialized);
var exists = await _context.WebhookEvents.AnyAsync(w => w.IdempotencyKey == idempotencyKey);
if (exists) { /* 既存 */ return; }
```
- 確認結果: Migrations配下に`IdempotencyKey`のインデックス追加は検出されず
- 実施内容: 既存テーブルへのユニークインデックス追加（Stg→Prod手順化）

## 3) 環境変数/設定の確認（WebhookSecret/Frontend URL）
- WebhookSecret参照箇所:
```445:451:backend/ShopifyAnalyticsApi/Controllers/WebhookController.cs
var secret = _configuration["Shopify:WebhookSecret"]; // 未設定時は検証NG
```
- 設定ファイルの現状（例）:
```69:72:backend/ShopifyAnalyticsApi/appsettings.Staging.json
"WebhookSecret": "your_staging_webhook_secret",
```
- 実施内容: Staging/Productionの実値投入、Azure App Service 構成確認

## 4) GDPRService/削除サービスの妥当性確認
- 実装済: `IGDPRService`, `GDPRService`, `IDataCleanupService`, `DataCleanupService`
- 重要ロジック:
```200:227:backend/ShopifyAnalyticsApi/Services/GDPRService.cs
// 顧客データをエクスポート→保存→完了
```
```262:286:backend/ShopifyAnalyticsApi/Services/GDPRService.cs
// 顧客データ削除と削除ログ記録
```
```314:325:backend/ShopifyAnalyticsApi/Services/GDPRService.cs
// ショップ全データ削除と削除ログ記録
```
- 実施内容: 本番データ量を想定したタイムアウト/トランザクション/例外時リトライの最終点検

## 5) E2E検証の証跡作成
- 4種WebhookのHMAC成功/失敗、重複、順不同、5秒応答、サイズ上限
- 取得手段: .http実行結果保存、Application Insightsクエリ、Hangfireダッシュボード履歴

## 6) ドキュメント整合
- 仕様のルート表記差異（`/api/webhooks/...` vs `/api/webhook/...`）の明示
- KQL/テスト手順の最新版反映

## 実施優先度
1. 本番スケジューリング実装（遅延ジョブ）
2. IdempotencyKeyユニーク制約追加
3. 環境変数最終化（WebhookSecret/Frontend URL）
4. E2E検証＋証跡
5. ドキュメント整合

