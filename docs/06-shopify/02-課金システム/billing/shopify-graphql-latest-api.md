# Shopify GraphQL Billing API ÊúÄÊñ∞‰ªïÊßòÔºà2024Âπ¥ÁâàÔºâ

## ‰ΩúÊàêÊó•Ôºö2025Âπ¥8Êúà12Êó•
## ‰ΩúÊàêËÄÖÔºöKenjiÔºà„Éó„É≠„Ç∏„Çß„ÇØ„Éà„Éû„Éç„Éº„Ç∏„É£„ÉºÔºâ

---

## üìå ÈáçË¶Å„Å™Â§âÊõ¥ÁÇπ

### API „Éê„Éº„Ç∏„Éß„É≥
- **Êé®Â•®„Éê„Éº„Ç∏„Éß„É≥**: 2024-01 ‰ª•Èôç
- **ÂªÉÊ≠¢‰∫àÂÆöAPI**: `recurringApplicationChargeCreate` ‚Üí `appSubscriptionCreate`„Å´ÁßªË°å

---

## 1. ÊúÄÊñ∞„ÅÆGraphQL„Éü„É•„Éº„ÉÜ„Éº„Ç∑„Éß„É≥

### 1.1 „Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥‰ΩúÊàêÔºà2024Âπ¥ÁâàÔºâ

```graphql
# Ê≠£„Åó„ÅÑÊúÄÊñ∞APIÂÆüË£Ö
mutation CreateAppSubscription($input: AppSubscriptionCreateInput!) {
  appSubscriptionCreate(appSubscription: $input) {
    appSubscription {
      id
      name
      status
      createdAt
      currentPeriodEnd
      test
      trialDays
      lineItems {
        id
        plan {
          pricingDetails {
            ... on AppRecurringPricing {
              price {
                amount
                currencyCode
              }
              interval
            }
          }
        }
      }
    }
    confirmationUrl
    userErrors {
      field
      message
      code
    }
  }
}
```

### 1.2 ÂÖ•Âäõ„Éë„É©„É°„Éº„ÇøÂÆöÁæ©

```graphql
input AppSubscriptionCreateInput {
  name: String!
  lineItems: [AppSubscriptionLineItemInput!]!
  returnUrl: URL!
  trialDays: Int
  test: Boolean
  replacementBehavior: AppSubscriptionReplacementBehavior
}

input AppSubscriptionLineItemInput {
  plan: AppPlanInput!
}

input AppPlanInput {
  appRecurringPricingDetails: AppRecurringPricingInput!
}

input AppRecurringPricingInput {
  price: MoneyInput!
  interval: AppPricingInterval!
}

input MoneyInput {
  amount: Decimal!
  currencyCode: CurrencyCode!
}

enum AppPricingInterval {
  EVERY_30_DAYS
  ANNUAL
}

enum AppSubscriptionReplacementBehavior {
  APPLY_IMMEDIATELY
  APPLY_ON_NEXT_BILLING_CYCLE
  STANDARD
}
```

---

## 2. C# ÂÆüË£Ö‰æãÔºàÊúÄÊñ∞ÁâàÔºâ

### 2.1 GraphQL„ÇØ„É©„Ç§„Ç¢„É≥„ÉàÂÆüË£Ö

```csharp
using GraphQL;
using GraphQL.Client.Http;
using GraphQL.Client.Serializer.Newtonsoft;

public class ShopifyBillingService
{
    private readonly GraphQLHttpClient _graphQLClient;
    private readonly IConfiguration _configuration;
    private readonly ILogger<ShopifyBillingService> _logger;

    public ShopifyBillingService(
        IConfiguration configuration,
        ILogger<ShopifyBillingService> logger)
    {
        _configuration = configuration;
        _logger = logger;
        
        var shopUrl = _configuration["Shopify:ShopUrl"];
        var accessToken = _configuration["Shopify:AccessToken"];
        
        _graphQLClient = new GraphQLHttpClient(
            $"https://{shopUrl}/admin/api/2024-01/graphql.json",
            new NewtonsoftJsonSerializer()
        );
        
        _graphQLClient.HttpClient.DefaultRequestHeaders.Add(
            "X-Shopify-Access-Token", accessToken
        );
    }

    public async Task<CreateSubscriptionResult> CreateSubscriptionAsync(
        string planName,
        decimal price,
        int trialDays = 7)
    {
        var mutation = new GraphQLRequest
        {
            Query = @"
                mutation CreateAppSubscription($input: AppSubscriptionCreateInput!) {
                  appSubscriptionCreate(appSubscription: $input) {
                    appSubscription {
                      id
                      name
                      status
                      currentPeriodEnd
                      trialDays
                    }
                    confirmationUrl
                    userErrors {
                      field
                      message
                      code
                    }
                  }
                }",
            Variables = new
            {
                input = new
                {
                    name = planName,
                    returnUrl = $"{_configuration["App:BaseUrl"]}/subscription/confirm",
                    trialDays = trialDays,
                    test = _configuration["Shopify:TestMode"] == "true",
                    lineItems = new[]
                    {
                        new
                        {
                            plan = new
                            {
                                appRecurringPricingDetails = new
                                {
                                    price = new
                                    {
                                        amount = price,
                                        currencyCode = "USD"
                                    },
                                    interval = "EVERY_30_DAYS"
                                }
                            }
                        }
                    }
                }
            }
        };

        try
        {
            var response = await _graphQLClient.SendMutationAsync<CreateSubscriptionResponse>(mutation);
            
            if (response.Errors?.Any() == true)
            {
                _logger.LogError("GraphQL errors: {Errors}", 
                    string.Join(", ", response.Errors.Select(e => e.Message)));
                throw new ShopifyApiException("Subscription creation failed");
            }

            var result = response.Data.AppSubscriptionCreate;
            
            if (result.UserErrors?.Any() == true)
            {
                _logger.LogWarning("User errors: {Errors}", 
                    string.Join(", ", result.UserErrors.Select(e => $"{e.Field}: {e.Message}")));
                throw new ShopifyApiException($"Subscription creation failed: {result.UserErrors.First().Message}");
            }

            return new CreateSubscriptionResult
            {
                SubscriptionId = result.AppSubscription.Id,
                ConfirmationUrl = result.ConfirmationUrl,
                Status = result.AppSubscription.Status
            };
        }
        catch (GraphQLHttpRequestException ex)
        {
            _logger.LogError(ex, "HTTP request failed");
            throw new ShopifyApiException("Failed to communicate with Shopify API", ex);
        }
    }
}
```

### 2.2 „É¨„Çπ„Éù„É≥„Çπ„É¢„Éá„É´

```csharp
public class CreateSubscriptionResponse
{
    public AppSubscriptionCreatePayload AppSubscriptionCreate { get; set; }
}

public class AppSubscriptionCreatePayload
{
    public AppSubscription AppSubscription { get; set; }
    public string ConfirmationUrl { get; set; }
    public List<UserError> UserErrors { get; set; }
}

public class AppSubscription
{
    public string Id { get; set; }
    public string Name { get; set; }
    public string Status { get; set; }
    public DateTime? CurrentPeriodEnd { get; set; }
    public int? TrialDays { get; set; }
    public bool Test { get; set; }
}

public class UserError
{
    public string Field { get; set; }
    public string Message { get; set; }
    public string Code { get; set; }
}

public class CreateSubscriptionResult
{
    public string SubscriptionId { get; set; }
    public string ConfirmationUrl { get; set; }
    public string Status { get; set; }
}
```

---

## 3. WebhookÊ§úË®º„ÅÆÂÖ∑‰ΩìÁöÑÂÆüË£Ö

### 3.1 Webhook„Ç≥„É≥„Éà„É≠„Éº„É©„Éº

```csharp
[ApiController]
[Route("api/webhook")]
public class WebhookController : ControllerBase
{
    private readonly IConfiguration _configuration;
    private readonly ShopifyDbContext _context;
    private readonly ILogger<WebhookController> _logger;

    public WebhookController(
        IConfiguration configuration,
        ShopifyDbContext context,
        ILogger<WebhookController> logger)
    {
        _configuration = configuration;
        _context = context;
        _logger = logger;
    }

    [HttpPost("subscription")]
    public async Task<IActionResult> HandleSubscriptionWebhook(
        [FromHeader(Name = "X-Shopify-Hmac-Sha256")] string hmacHeader,
        [FromHeader(Name = "X-Shopify-Topic")] string topic,
        [FromHeader(Name = "X-Shopify-Shop-Domain")] string shopDomain,
        [FromHeader(Name = "X-Shopify-Webhook-Id")] string webhookId)
    {
        using var reader = new StreamReader(Request.Body);
        var rawBody = await reader.ReadToEndAsync();
        
        // 1. ÁΩ≤ÂêçÊ§úË®º
        if (!VerifyWebhookSignature(rawBody, hmacHeader))
        {
            _logger.LogWarning("Invalid webhook signature from shop: {Shop}", shopDomain);
            return Unauthorized("Invalid signature");
        }

        // 2. ÂÜ™Á≠âÊÄß„ÅÆ‰øùË®º
        if (await _context.WebhookEvents.AnyAsync(w => w.WebhookId == webhookId))
        {
            _logger.LogInformation("Webhook already processed: {WebhookId}", webhookId);
            return Ok("Already processed");
        }

        try
        {
            // 3. Webhook„Ç§„Éô„É≥„Éà„ÇíË®òÈå≤
            var webhookEvent = new WebhookEvent
            {
                WebhookId = webhookId,
                Topic = topic,
                ShopDomain = shopDomain,
                Payload = rawBody,
                ReceivedAt = DateTime.UtcNow,
                ProcessedAt = null,
                Status = "Pending"
            };
            
            _context.WebhookEvents.Add(webhookEvent);
            await _context.SaveChangesAsync();

            // 4. „Éà„Éî„ÉÉ„ÇØ„Å´Âøú„Åò„ÅüÂá¶ÁêÜ
            var processed = topic switch
            {
                "app_subscriptions/update" => await ProcessSubscriptionUpdate(rawBody, shopDomain),
                "app_subscriptions/cancel" => await ProcessSubscriptionCancel(rawBody, shopDomain),
                "app/uninstalled" => await ProcessAppUninstalled(rawBody, shopDomain),
                _ => false
            };

            // 5. Âá¶ÁêÜÁµêÊûú„ÇíÊõ¥Êñ∞
            webhookEvent.ProcessedAt = DateTime.UtcNow;
            webhookEvent.Status = processed ? "Completed" : "Failed";
            await _context.SaveChangesAsync();

            return Ok();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to process webhook: {WebhookId}", webhookId);
            
            // „Ç®„É©„Éº„ÇíË®òÈå≤
            var webhookEvent = await _context.WebhookEvents
                .FirstOrDefaultAsync(w => w.WebhookId == webhookId);
            
            if (webhookEvent != null)
            {
                webhookEvent.Status = "Error";
                webhookEvent.ErrorMessage = ex.Message;
                await _context.SaveChangesAsync();
            }
            
            // Shopify„Å´„ÅØÊàêÂäü„ÇíËøî„ÅôÔºà„É™„Éà„É©„Ç§Èò≤Ê≠¢Ôºâ
            return Ok();
        }
    }

    private bool VerifyWebhookSignature(string rawBody, string hmacHeader)
    {
        var secret = _configuration["Shopify:WebhookSecret"];
        
        using var hmac = new HMACSHA256(Encoding.UTF8.GetBytes(secret));
        var hash = Convert.ToBase64String(hmac.ComputeHash(Encoding.UTF8.GetBytes(rawBody)));
        
        return hash == hmacHeader;
    }

    private async Task<bool> ProcessSubscriptionUpdate(string rawBody, string shopDomain)
    {
        var webhook = JsonSerializer.Deserialize<SubscriptionUpdateWebhook>(rawBody);
        
        var store = await _context.Stores
            .FirstOrDefaultAsync(s => s.ShopDomain == shopDomain);
        
        if (store == null)
        {
            _logger.LogWarning("Store not found: {Shop}", shopDomain);
            return false;
        }

        var subscription = await _context.StoreSubscriptions
            .FirstOrDefaultAsync(s => s.StoreId == store.Id && 
                                     s.ShopifySubscriptionId == webhook.Id);
        
        if (subscription == null)
        {
            // Êñ∞Ë¶è„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥
            subscription = new StoreSubscription
            {
                StoreId = store.Id,
                ShopifySubscriptionId = webhook.Id,
                PlanName = webhook.Name,
                Status = webhook.Status,
                CurrentPeriodEnd = webhook.CurrentPeriodEnd,
                CreatedAt = DateTime.UtcNow
            };
            _context.StoreSubscriptions.Add(subscription);
        }
        else
        {
            // Êó¢Â≠ò„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥„ÅÆÊõ¥Êñ∞
            subscription.Status = webhook.Status;
            subscription.CurrentPeriodEnd = webhook.CurrentPeriodEnd;
            subscription.UpdatedAt = DateTime.UtcNow;
        }

        await _context.SaveChangesAsync();
        
        _logger.LogInformation("Subscription updated for store {Store}: {Status}", 
            shopDomain, webhook.Status);
        
        return true;
    }

    private async Task<bool> ProcessSubscriptionCancel(string rawBody, string shopDomain)
    {
        // „Ç≠„É£„É≥„Çª„É´Âá¶ÁêÜ
        var webhook = JsonSerializer.Deserialize<SubscriptionCancelWebhook>(rawBody);
        
        var store = await _context.Stores
            .FirstOrDefaultAsync(s => s.ShopDomain == shopDomain);
        
        if (store == null) return false;

        var subscription = await _context.StoreSubscriptions
            .FirstOrDefaultAsync(s => s.StoreId == store.Id && 
                                     s.ShopifySubscriptionId == webhook.Id);
        
        if (subscription != null)
        {
            subscription.Status = "cancelled";
            subscription.CancelledAt = DateTime.UtcNow;
            subscription.CancellationReason = webhook.CancellationReason;
            await _context.SaveChangesAsync();
        }
        
        return true;
    }

    private async Task<bool> ProcessAppUninstalled(string rawBody, string shopDomain)
    {
        // „Ç¢„É≥„Ç§„É≥„Çπ„Éà„Éº„É´Âá¶ÁêÜ
        var store = await _context.Stores
            .FirstOrDefaultAsync(s => s.ShopDomain == shopDomain);
        
        if (store == null) return false;

        store.IsActive = false;
        store.UninstalledAt = DateTime.UtcNow;
        
        // „Åô„Åπ„Å¶„ÅÆ„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥„ÇíÁÑ°ÂäπÂåñ
        var subscriptions = await _context.StoreSubscriptions
            .Where(s => s.StoreId == store.Id && s.Status == "active")
            .ToListAsync();
        
        foreach (var subscription in subscriptions)
        {
            subscription.Status = "cancelled";
            subscription.CancelledAt = DateTime.UtcNow;
            subscription.CancellationReason = "App uninstalled";
        }
        
        await _context.SaveChangesAsync();
        
        return true;
    }
}
```

### 3.2 Webhook„É¢„Éá„É´

```csharp
public class WebhookEvent
{
    public int Id { get; set; }
    public string WebhookId { get; set; }
    public string Topic { get; set; }
    public string ShopDomain { get; set; }
    public string Payload { get; set; }
    public DateTime ReceivedAt { get; set; }
    public DateTime? ProcessedAt { get; set; }
    public string Status { get; set; }
    public string ErrorMessage { get; set; }
}

public class SubscriptionUpdateWebhook
{
    [JsonPropertyName("id")]
    public string Id { get; set; }
    
    [JsonPropertyName("name")]
    public string Name { get; set; }
    
    [JsonPropertyName("status")]
    public string Status { get; set; }
    
    [JsonPropertyName("current_period_end")]
    public DateTime? CurrentPeriodEnd { get; set; }
    
    [JsonPropertyName("trial_ends_on")]
    public DateTime? TrialEndsOn { get; set; }
}

public class SubscriptionCancelWebhook
{
    [JsonPropertyName("id")]
    public string Id { get; set; }
    
    [JsonPropertyName("cancellation_reason")]
    public string CancellationReason { get; set; }
}
```

---

## 4. „ÉÜ„Çπ„ÉàÂÆüË£Ö

```csharp
[TestClass]
public class ShopifyBillingServiceTests
{
    [TestMethod]
    public async Task CreateSubscription_Should_Return_ConfirmationUrl()
    {
        // Arrange
        var service = new ShopifyBillingService(
            GetMockConfiguration(),
            GetMockLogger()
        );
        
        // Act
        var result = await service.CreateSubscriptionAsync(
            "Professional Plan",
            80.00m,
            7
        );
        
        // Assert
        Assert.IsNotNull(result);
        Assert.IsNotNull(result.ConfirmationUrl);
        Assert.IsNotNull(result.SubscriptionId);
        Assert.AreEqual("pending", result.Status);
    }
    
    [TestMethod]
    public void VerifyWebhookSignature_Should_Validate_Correctly()
    {
        // Arrange
        var secret = "test_secret";
        var body = "{\"id\":\"123\",\"status\":\"active\"}";
        var expectedSignature = ComputeSignature(body, secret);
        
        // Act & Assert
        Assert.IsTrue(VerifySignature(body, expectedSignature, secret));
    }
}
```

---

## 5. Ê≥®ÊÑè‰∫ãÈ†Ö

### API „Éê„Éº„Ç∏„Éß„É≥ÁÆ°ÁêÜ
- Â∏∏„Å´ÊúÄÊñ∞„ÅÆÂÆâÂÆöÁâàAPI„Çí‰ΩøÁî®
- ÂªÉÊ≠¢‰∫àÂÆö„ÅÆAPI„ÅØÊó©„ÇÅ„Å´ÁßªË°å
- „Éê„Éº„Ç∏„Éß„É≥„ÅØ„Éò„ÉÉ„ÉÄ„Éº„ÅßÊòéÁ§∫ÁöÑ„Å´ÊåáÂÆö

### „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞
- GraphQL„Ç®„É©„Éº„Å®„É¶„Éº„Ç∂„Éº„Ç®„É©„Éº„ÇíÂå∫Âà•
- „É¨„Éº„ÉàÂà∂Èôê„ÇíËÄÉÊÖÆ
- „Çø„Ç§„É†„Ç¢„Ç¶„ÉàË®≠ÂÆöÔºà30ÁßíÊé®Â•®Ôºâ

### „Çª„Ç≠„É•„É™„ÉÜ„Ç£
- WebhookÁΩ≤Âêç„ÅØÂøÖ„ÅöÊ§úË®º
- „Ç¢„ÇØ„Çª„Çπ„Éà„Éº„ÇØ„É≥„ÅØÁí∞Â¢ÉÂ§âÊï∞„ÅßÁÆ°ÁêÜ
- HTTPS„ÅÆ„Åø‰ΩøÁî®

---

**ÊúÄÁµÇÊõ¥Êñ∞**: 2025Âπ¥8Êúà12Êó•
**API „Éê„Éº„Ç∏„Éß„É≥**: 2024-01