# 無料プラン機能制限 技術設計詳細書

> **作成日**: 2025年8月24日  
> **作成者**: Kenji（AIプロジェクトマネージャー）  
> **バージョン**: 1.1  
> **状態**: 実装準備中（レビュー反映済み）

## 1. システムアーキテクチャ

### 1.1 全体構成
```
┌─────────────────────────────────────────────────┐
│                  Frontend (React)                │
│  ┌─────────────┐ ┌──────────────┐ ┌──────────┐ │
│  │Feature      │ │Feature Usage │ │Upgrade   │ │
│  │Selector     │ │Monitor       │ │Prompt    │ │
│  └─────────────┘ └──────────────┘ └──────────┘ │
└─────────────────────────────────────────────────┘
                          │
                    ▼─────▼─────▼
┌─────────────────────────────────────────────────┐
│           Backend API (.NET 8)                  │
│  ┌──────────────────────────────────────────┐  │
│  │     Feature Selection Service             │  │
│  │  - validateFeatureChange()                │  │
│  │  - applyFeatureSelection()                │  │
│  │  - trackFeatureUsage()                    │  │
│  └──────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────┐  │
│  │     Feature Access Control                │  │
│  │  - checkFeatureAccess()                   │  │
│  │  - enforceUsageLimits()                   │  │
│  └──────────────────────────────────────────┘  │
└─────────────────────────────────────────────────┘
                          │
                    ▼─────▼─────▼
┌─────────────────────────────────────────────────┐
│              Database (SQL Server)              │
│  ┌──────────────┐ ┌──────────────┐            │
│  │UserFeature   │ │FeatureUsage  │            │
│  │Selections    │ │Logs          │            │
│  └──────────────┘ └──────────────┘            │
└─────────────────────────────────────────────────┘
```

## 2. データベース詳細設計

### 2.1 テーブル定義

#### UserFeatureSelections テーブル
```sql
CREATE TABLE UserFeatureSelections (
    Id INT PRIMARY KEY IDENTITY(1,1),
    StoreId INT NOT NULL,
    SelectedFeature NVARCHAR(50) NOT NULL,
    SelectionDate DATETIME2 NOT NULL DEFAULT GETUTCDATE(),
    LastChangeDate DATETIME2 NULL,
    NextChangeAvailableDate DATETIME2 NOT NULL,
    ChangeCount INT DEFAULT 0,
    TrialEndDate DATETIME2 NULL, -- 機能お試し期間終了日
    IsActive BIT DEFAULT 1,
    CreatedAt DATETIME2 DEFAULT GETUTCDATE(),
    UpdatedAt DATETIME2 DEFAULT GETUTCDATE(),
    CONSTRAINT FK_UserFeatureSelections_Stores 
        FOREIGN KEY (StoreId) REFERENCES Stores(Id),
    CONSTRAINT CK_SelectedFeature 
        CHECK (SelectedFeature IN ('dormant_analysis', 'yoy_comparison', 'purchase_frequency'))
);

-- インデックス
CREATE UNIQUE INDEX IX_UserFeatureSelections_StoreId_Active 
    ON UserFeatureSelections(StoreId) 
    WHERE IsActive = 1;
CREATE INDEX IX_UserFeatureSelections_NextChangeDate 
    ON UserFeatureSelections(NextChangeAvailableDate);
```

#### FeatureUsageLogs テーブル
```sql
CREATE TABLE FeatureUsageLogs (
    Id INT PRIMARY KEY IDENTITY(1,1),
    StoreId INT NOT NULL,
    Feature NVARCHAR(50) NOT NULL,
    Action NVARCHAR(100) NOT NULL,
    RequestPayload NVARCHAR(MAX) NULL, -- JSON形式のリクエスト詳細
    ResponseStatus NVARCHAR(20) NOT NULL, -- 'success', 'limited', 'error'
    UsageCount INT DEFAULT 1,
    DataPointsProcessed INT NULL, -- 処理したデータポイント数
    ExecutionTimeMs INT NULL, -- 実行時間（ミリ秒）
    UsageDate DATE NOT NULL,
    CreatedAt DATETIME2 DEFAULT GETUTCDATE(),
    CONSTRAINT FK_FeatureUsageLogs_Stores 
        FOREIGN KEY (StoreId) REFERENCES Stores(Id)
);

-- インデックス
CREATE INDEX IX_FeatureUsageLogs_StoreId_Feature_Date 
    ON FeatureUsageLogs(StoreId, Feature, UsageDate);
CREATE INDEX IX_FeatureUsageLogs_ResponseStatus 
    ON FeatureUsageLogs(ResponseStatus);
```

#### FeatureLimits テーブル（マスタデータ）
```sql
CREATE TABLE FeatureLimits (
    Id INT PRIMARY KEY IDENTITY(1,1),
    Feature NVARCHAR(50) NOT NULL UNIQUE,
    LimitType NVARCHAR(50) NOT NULL, -- 'customer_count', 'report_generation', 'data_period'
    LimitValue INT NOT NULL,
    LimitUnit NVARCHAR(20) NOT NULL, -- 'count', 'days', 'months'
    Description NVARCHAR(500) NULL,
    CreatedAt DATETIME2 DEFAULT GETUTCDATE(),
    UpdatedAt DATETIME2 DEFAULT GETUTCDATE()
);

-- 初期データ投入
INSERT INTO FeatureLimits (Feature, LimitType, LimitValue, LimitUnit, Description) VALUES
-- 休眠顧客分析の制限
('dormant_analysis', 'customer_count', 1000, 'count', '分析対象顧客数の上限'),
('dormant_analysis', 'data_period', 180, 'days', 'データ取得期間'),
('dormant_analysis', 'report_generation', 2, 'count', '月間レポート生成回数'),
-- 前年同月比分析の制限
('yoy_comparison', 'comparison_period', 12, 'months', '比較可能期間'),
('yoy_comparison', 'category_count', 10, 'count', '商品カテゴリ数上限'),
('yoy_comparison', 'segment_count', 5, 'count', 'セグメント数上限'),
-- 購入回数詳細分析の制限
('purchase_frequency', 'data_period', 6, 'months', '分析対象期間'),
('purchase_frequency', 'customer_count', 2000, 'count', '分析対象顧客数'),
('purchase_frequency', 'forecast_period', 30, 'days', '予測期間');
```

### 2.2 ストアドプロシージャ

#### 機能選択の変更処理
```sql
CREATE PROCEDURE sp_ChangeFeatureSelection
    @StoreId INT,
    @NewFeature NVARCHAR(50),
    @Result INT OUTPUT,
    @Message NVARCHAR(500) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    BEGIN TRANSACTION;
    
    BEGIN TRY
        -- 現在の選択状態を確認
        DECLARE @CurrentFeature NVARCHAR(50);
        DECLARE @LastChangeDate DATETIME2;
        DECLARE @NextChangeAvailable DATETIME2;
        
        SELECT 
            @CurrentFeature = SelectedFeature,
            @LastChangeDate = LastChangeDate,
            @NextChangeAvailable = NextChangeAvailableDate
        FROM UserFeatureSelections
        WHERE StoreId = @StoreId AND IsActive = 1;
        
        -- 変更可能かチェック
        IF @NextChangeAvailable > GETUTCDATE()
        BEGIN
            SET @Result = 0;
            SET @Message = '機能変更は ' + CONVERT(NVARCHAR, @NextChangeAvailable, 120) + ' 以降に可能です';
            ROLLBACK TRANSACTION;
            RETURN;
        END
        
        -- 現在の選択を無効化
        UPDATE UserFeatureSelections
        SET IsActive = 0, UpdatedAt = GETUTCDATE()
        WHERE StoreId = @StoreId AND IsActive = 1;
        
        -- 新しい選択を挿入
        INSERT INTO UserFeatureSelections (
            StoreId, 
            SelectedFeature, 
            SelectionDate,
            LastChangeDate,
            NextChangeAvailableDate,
            ChangeCount
        ) VALUES (
            @StoreId,
            @NewFeature,
            GETUTCDATE(),
            GETUTCDATE(),
            DATEADD(MONTH, 1, DATEADD(DAY, 1-DAY(GETUTCDATE()), CAST(CAST(GETUTCDATE() AS DATE) AS DATETIME2))),
            ISNULL((SELECT MAX(ChangeCount) FROM UserFeatureSelections WHERE StoreId = @StoreId), 0) + 1
        );
        
        -- ログ記録
        INSERT INTO FeatureUsageLogs (
            StoreId, Feature, Action, ResponseStatus, UsageDate
        ) VALUES (
            @StoreId, @NewFeature, 'feature_changed', 'success', CAST(GETUTCDATE() AS DATE)
        );
        
        SET @Result = 1;
        SET @Message = '機能を' + @NewFeature + 'に変更しました';
        COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        ROLLBACK TRANSACTION;
        SET @Result = -1;
        SET @Message = ERROR_MESSAGE();
    END CATCH
END
```

## 3. API詳細設計

### 3.1 コントローラー実装

#### FeatureSelectionController.cs
```csharp
[ApiController]
[Route("api/[controller]")]
[Authorize]
public class FeatureSelectionController : ControllerBase
{
    private readonly IFeatureSelectionService _featureService;
    private readonly ILogger<FeatureSelectionController> _logger;

    public FeatureSelectionController(
        IFeatureSelectionService featureService,
        ILogger<FeatureSelectionController> logger)
    {
        _featureService = featureService;
        _logger = logger;
    }

    /// <summary>
    /// 現在の機能選択状態を取得
    /// </summary>
    [HttpGet("current")]
    public async Task<IActionResult> GetCurrentSelection()
    {
        try
        {
            var storeId = GetStoreId();
            var selection = await _featureService.GetCurrentSelectionAsync(storeId);
            
            if (selection == null)
            {
                return Ok(new FeatureSelectionResponse
                {
                    SelectedFeature = null,
                    IsFirstSelection = true,
                    Message = "機能を選択してください"
                });
            }

            return Ok(selection);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to get current feature selection");
            return StatusCode(500, new { error = "機能選択情報の取得に失敗しました" });
        }
    }

    /// <summary>
    /// 機能を選択または変更
    /// </summary>
    [HttpPost("select")]
    public async Task<IActionResult> SelectFeature([FromBody] SelectFeatureRequest request)
    {
        try
        {
            // 入力検証
            if (!IsValidFeature(request.Feature))
            {
                return BadRequest(new { error = "無効な機能が指定されました" });
            }

            var storeId = GetStoreId();
            var result = await _featureService.SelectFeatureAsync(storeId, request.Feature);

            if (!result.Success)
            {
                return BadRequest(new { error = result.Message });
            }

            // 成功時はキャッシュをクリア
            await _featureService.ClearFeatureCacheAsync(storeId);

            return Ok(result);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to select feature");
            return StatusCode(500, new { error = "機能選択に失敗しました" });
        }
    }

    /// <summary>
    /// 利用可能な機能と制限の詳細を取得
    /// </summary>
    [HttpGet("available-features")]
    public async Task<IActionResult> GetAvailableFeatures()
    {
        try
        {
            var storeId = GetStoreId();
            var features = await _featureService.GetAvailableFeaturesAsync(storeId);
            return Ok(features);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to get available features");
            return StatusCode(500, new { error = "機能情報の取得に失敗しました" });
        }
    }

    /// <summary>
    /// 機能の使用状況を取得
    /// </summary>
    [HttpGet("usage/{feature}")]
    public async Task<IActionResult> GetFeatureUsage(string feature)
    {
        try
        {
            var storeId = GetStoreId();
            var usage = await _featureService.GetFeatureUsageAsync(storeId, feature);
            return Ok(usage);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to get feature usage");
            return StatusCode(500, new { error = "使用状況の取得に失敗しました" });
        }
    }

    private int GetStoreId()
    {
        // ClaimからStoreIdを取得
        var storeIdClaim = User.FindFirst("StoreId");
        if (storeIdClaim == null || !int.TryParse(storeIdClaim.Value, out var storeId))
        {
            throw new UnauthorizedAccessException("Store ID not found");
        }
        return storeId;
    }

    private bool IsValidFeature(string feature)
    {
        var validFeatures = new[] { "dormant_analysis", "yoy_comparison", "purchase_frequency" };
        return validFeatures.Contains(feature);
    }
}
```

### 3.2 サービス層実装

#### IFeatureSelectionService.cs
```csharp
public interface IFeatureSelectionService
{
    Task<FeatureSelectionResponse> GetCurrentSelectionAsync(int storeId);
    Task<SelectFeatureResult> SelectFeatureAsync(int storeId, string feature);
    Task<List<AvailableFeature>> GetAvailableFeaturesAsync(int storeId);
    Task<FeatureUsageResponse> GetFeatureUsageAsync(int storeId, string feature);
    Task<bool> CheckFeatureAccessAsync(int storeId, string feature, string action);
    Task LogFeatureUsageAsync(int storeId, string feature, string action, bool success);
    Task ClearFeatureCacheAsync(int storeId);
}
```

#### FeatureSelectionService.cs
```csharp
public class FeatureSelectionService : IFeatureSelectionService
{
    private readonly ShopifyDbContext _context;
    private readonly IMemoryCache _cache;
    private readonly ILogger<FeatureSelectionService> _logger;

    public FeatureSelectionService(
        ShopifyDbContext context,
        IMemoryCache cache,
        ILogger<FeatureSelectionService> logger)
    {
        _context = context;
        _cache = cache;
        _logger = logger;
    }

    public async Task<FeatureSelectionResponse> GetCurrentSelectionAsync(int storeId)
    {
        // キャッシュから取得を試みる
        var cacheKey = $"feature_selection_{storeId}";
        if (_cache.TryGetValue<FeatureSelectionResponse>(cacheKey, out var cached))
        {
            return cached;
        }

        var selection = await _context.UserFeatureSelections
            .Where(x => x.StoreId == storeId && x.IsActive)
            .Select(x => new FeatureSelectionResponse
            {
                SelectedFeature = x.SelectedFeature,
                LastChangeDate = x.LastChangeDate,
                NextChangeAvailableDate = x.NextChangeAvailableDate,
                ChangeCount = x.ChangeCount,
                CanChangeToday = x.NextChangeAvailableDate <= DateTime.UtcNow,
                IsFirstSelection = false
            })
            .FirstOrDefaultAsync();

        if (selection != null)
        {
            // キャッシュに5分間保存
            _cache.Set(cacheKey, selection, TimeSpan.FromMinutes(5));
        }

        return selection;
    }

    public async Task<SelectFeatureResult> SelectFeatureAsync(int storeId, string feature)
    {
        using var transaction = await _context.Database.BeginTransactionAsync();
        
        try
        {
            // 現在の選択を確認
            var currentSelection = await _context.UserFeatureSelections
                .Where(x => x.StoreId == storeId && x.IsActive)
                .FirstOrDefaultAsync();

            // 初回選択の場合
            if (currentSelection == null)
            {
                var newSelection = new UserFeatureSelection
                {
                    StoreId = storeId,
                    SelectedFeature = feature,
                    SelectionDate = DateTime.UtcNow,
                    NextChangeAvailableDate = GetNextChangeDate(),
                    ChangeCount = 0,
                    IsActive = true
                };

                _context.UserFeatureSelections.Add(newSelection);
                await _context.SaveChangesAsync();
                await transaction.CommitAsync();

                await LogFeatureUsageAsync(storeId, feature, "initial_selection", true);

                return new SelectFeatureResult
                {
                    Success = true,
                    Message = $"{GetFeatureName(feature)}を選択しました",
                    NewSelection = new FeatureInfo
                    {
                        Feature = feature,
                        ActivatedAt = DateTime.UtcNow
                    }
                };
            }

            // 変更可能かチェック
            if (currentSelection.NextChangeAvailableDate > DateTime.UtcNow)
            {
                return new SelectFeatureResult
                {
                    Success = false,
                    Message = $"機能変更は{currentSelection.NextChangeAvailableDate:yyyy年MM月dd日}以降に可能です"
                };
            }

            // 同じ機能への変更はエラー
            if (currentSelection.SelectedFeature == feature)
            {
                return new SelectFeatureResult
                {
                    Success = false,
                    Message = "既に選択されている機能です"
                };
            }

            // 現在の選択を無効化
            currentSelection.IsActive = false;
            currentSelection.UpdatedAt = DateTime.UtcNow;

            // 新しい選択を作成
            var newFeatureSelection = new UserFeatureSelection
            {
                StoreId = storeId,
                SelectedFeature = feature,
                SelectionDate = DateTime.UtcNow,
                LastChangeDate = DateTime.UtcNow,
                NextChangeAvailableDate = GetNextChangeDate(),
                ChangeCount = currentSelection.ChangeCount + 1,
                IsActive = true
            };

            _context.UserFeatureSelections.Add(newFeatureSelection);
            await _context.SaveChangesAsync();
            await transaction.CommitAsync();

            await LogFeatureUsageAsync(storeId, feature, "feature_changed", true);

            return new SelectFeatureResult
            {
                Success = true,
                Message = $"{GetFeatureName(feature)}に変更しました",
                NewSelection = new FeatureInfo
                {
                    Feature = feature,
                    ActivatedAt = DateTime.UtcNow
                }
            };
        }
        catch (Exception ex)
        {
            await transaction.RollbackAsync();
            _logger.LogError(ex, "Failed to select feature for store {StoreId}", storeId);
            
            return new SelectFeatureResult
            {
                Success = false,
                Message = "機能選択中にエラーが発生しました"
            };
        }
    }

    public async Task<bool> CheckFeatureAccessAsync(int storeId, string feature, string action)
    {
        // 現在選択されている機能を確認
        var currentSelection = await GetCurrentSelectionAsync(storeId);
        if (currentSelection?.SelectedFeature != feature)
        {
            return false;
        }

        // 使用制限をチェック
        var limits = await GetFeatureLimitsAsync(feature);
        var usage = await GetCurrentMonthUsageAsync(storeId, feature, action);

        foreach (var limit in limits)
        {
            if (limit.LimitType == action && usage >= limit.LimitValue)
            {
                return false;
            }
        }

        return true;
    }

    public async Task LogFeatureUsageAsync(int storeId, string feature, string action, bool success)
    {
        var log = new FeatureUsageLog
        {
            StoreId = storeId,
            Feature = feature,
            Action = action,
            ResponseStatus = success ? "success" : "limited",
            UsageDate = DateTime.UtcNow.Date,
            CreatedAt = DateTime.UtcNow
        };

        _context.FeatureUsageLogs.Add(log);
        await _context.SaveChangesAsync();
    }

    private DateTime GetNextChangeDate()
    {
        var now = DateTime.UtcNow;
        var nextMonth = now.AddMonths(1);
        return new DateTime(nextMonth.Year, nextMonth.Month, 1, 0, 0, 0, DateTimeKind.Utc);
    }

    private string GetFeatureName(string feature)
    {
        return feature switch
        {
            "dormant_analysis" => "休眠顧客分析",
            "yoy_comparison" => "前年同月比分析",
            "purchase_frequency" => "購入回数詳細分析",
            _ => feature
        };
    }

    // その他のヘルパーメソッド...
}
```

## 4. フロントエンド詳細設計

### 4.1 コンポーネント構成

#### ディレクトリ構造
```
/frontend/src/
├── components/
│   └── free-plan/
│       ├── FeatureSelector.tsx       # 機能選択メインコンポーネント
│       ├── FeatureCard.tsx           # 個別機能カード
│       ├── FeatureComparison.tsx     # 機能比較表
│       ├── ChangeFeatureModal.tsx    # 機能変更確認モーダル
│       ├── UsageLimitAlert.tsx       # 使用制限アラート
│       └── UpgradePrompt.tsx         # アップグレード促進
├── hooks/
│   ├── useFeatureSelection.ts        # 機能選択カスタムフック
│   └── useFeatureAccess.ts           # 機能アクセス制御フック
├── stores/
│   └── featureSelectionStore.ts      # Zustand store
└── lib/
    └── api/
        └── featureSelection.ts        # API クライアント
```

### 4.2 主要コンポーネント実装

#### FeatureSelector.tsx
```typescript
import React, { useState, useEffect } from 'react';
import { Card, Button, Alert, Modal, Badge } from 'antd';
import { CheckCircleOutlined, ClockCircleOutlined, SwapOutlined } from '@ant-design/icons';
import { useFeatureSelection } from '@/hooks/useFeatureSelection';
import FeatureCard from './FeatureCard';
import ChangeFeatureModal from './ChangeFeatureModal';
import { formatDate } from '@/utils/date';

interface Feature {
  id: string;
  name: string;
  description: string;
  highlights: string[];
  limitations: Record<string, any>;
  icon: React.ReactNode;
}

const features: Feature[] = [
  {
    id: 'dormant_analysis',
    name: '休眠顧客分析',
    description: '購買が停止した顧客を特定し、復活施策を提案',
    highlights: [
      '休眠顧客の自動検出',
      '復活可能性スコアリング',
      '最適な復活施策の提案',
      '施策効果の予測'
    ],
    limitations: {
      customerCount: 1000,
      dataRetention: 180,
      reportGeneration: 2
    },
    icon: <UserDeleteOutlined />
  },
  {
    id: 'yoy_comparison',
    name: '前年同月比分析',
    description: '売上や顧客動向を前年同月と比較分析',
    highlights: [
      '売上高の前年比較',
      'カテゴリ別成長率分析',
      '顧客セグメント別推移',
      'トレンド予測'
    ],
    limitations: {
      comparisonPeriod: 12,
      categoryCount: 10,
      segmentCount: 5
    },
    icon: <LineChartOutlined />
  },
  {
    id: 'purchase_frequency',
    name: '購入回数詳細分析',
    description: '顧客の購入パターンを分析し、次回購入を予測',
    highlights: [
      '購入回数別の顧客分布',
      'リピート率の推移分析',
      '購入間隔の詳細分析',
      '次回購入予測'
    ],
    limitations: {
      dataPeriod: 6,
      customerCount: 2000,
      forecastPeriod: 30
    },
    icon: <ShoppingCartOutlined />
  }
];

export const FeatureSelector: React.FC = () => {
  const {
    currentSelection,
    isLoading,
    canChange,
    selectFeature,
    getNextChangeDate
  } = useFeatureSelection();

  const [isModalVisible, setIsModalVisible] = useState(false);
  const [selectedFeature, setSelectedFeature] = useState<string | null>(null);

  const handleSelectFeature = (featureId: string) => {
    if (currentSelection?.selectedFeature === featureId) {
      return;
    }
    
    if (currentSelection?.selectedFeature && !canChange) {
      // 変更不可の場合はアラート表示
      Modal.warning({
        title: '機能変更はまだできません',
        content: `次回の変更可能日: ${formatDate(getNextChangeDate())}`,
      });
      return;
    }

    setSelectedFeature(featureId);
    setIsModalVisible(true);
  };

  const handleConfirmChange = async () => {
    if (!selectedFeature) return;

    const result = await selectFeature(selectedFeature);
    if (result.success) {
      Modal.success({
        title: '機能を変更しました',
        content: result.message,
      });
      setIsModalVisible(false);
      setSelectedFeature(null);
    } else {
      Modal.error({
        title: '変更に失敗しました',
        content: result.message,
      });
    }
  };

  if (isLoading) {
    return <div>読み込み中...</div>;
  }

  return (
    <div className="feature-selector">
      {/* 現在の選択状態の表示 */}
      {currentSelection?.selectedFeature && (
        <Alert
          message="現在選択中の機能"
          description={
            <div>
              <strong>
                {features.find(f => f.id === currentSelection.selectedFeature)?.name}
              </strong>
              {canChange ? (
                <Badge status="success" text="変更可能" style={{ marginLeft: 16 }} />
              ) : (
                <Badge 
                  status="default" 
                  text={`次回変更可能: ${formatDate(getNextChangeDate())}`} 
                  style={{ marginLeft: 16 }} 
                />
              )}
            </div>
          }
          type="info"
          showIcon
          icon={<CheckCircleOutlined />}
          style={{ marginBottom: 24 }}
        />
      )}

      {/* 機能カードの表示 */}
      <div className="feature-cards">
        {features.map(feature => (
          <FeatureCard
            key={feature.id}
            feature={feature}
            isSelected={currentSelection?.selectedFeature === feature.id}
            isDisabled={!canChange && currentSelection?.selectedFeature !== feature.id}
            onSelect={() => handleSelectFeature(feature.id)}
          />
        ))}
      </div>

      {/* 機能変更確認モーダル */}
      <ChangeFeatureModal
        visible={isModalVisible}
        feature={features.find(f => f.id === selectedFeature)}
        currentFeature={features.find(f => f.id === currentSelection?.selectedFeature)}
        onConfirm={handleConfirmChange}
        onCancel={() => {
          setIsModalVisible(false);
          setSelectedFeature(null);
        }}
      />

      {/* 使い方のヒント */}
      <Alert
        message="無料プランの機能選択について"
        description={
          <ul>
            <li>3つの主要機能から1つを選択して利用できます</li>
            <li>機能は月1回まで変更可能です（毎月1日にリセット）</li>
            <li>すべての機能を利用したい場合は有料プランへのアップグレードをご検討ください</li>
          </ul>
        }
        type="info"
        style={{ marginTop: 24 }}
      />
    </div>
  );
};
```

### 4.3 状態管理（Zustand Store）

#### featureSelectionStore.ts
```typescript
import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';
import { featureSelectionApi } from '@/lib/api/featureSelection';

interface FeatureSelectionState {
  // State
  selectedFeature: string | null;
  lastChangeDate: Date | null;
  nextChangeDate: Date | null;
  canChangeToday: boolean;
  changeCount: number;
  isLoading: boolean;
  error: string | null;
  
  // Usage tracking
  currentUsage: Record<string, number>;
  usageLimits: Record<string, number>;
  
  // Actions
  fetchCurrentSelection: () => Promise<void>;
  selectFeature: (feature: string) => Promise<{ success: boolean; message: string }>;
  checkFeatureAccess: (feature: string, action: string) => Promise<boolean>;
  trackUsage: (feature: string, action: string) => void;
  clearError: () => void;
}

export const useFeatureSelectionStore = create<FeatureSelectionState>()(
  devtools(
    persist(
      (set, get) => ({
        // Initial state
        selectedFeature: null,
        lastChangeDate: null,
        nextChangeDate: null,
        canChangeToday: false,
        changeCount: 0,
        isLoading: false,
        error: null,
        currentUsage: {},
        usageLimits: {},

        // Fetch current selection
        fetchCurrentSelection: async () => {
          set({ isLoading: true, error: null });
          
          try {
            const response = await featureSelectionApi.getCurrentSelection();
            
            set({
              selectedFeature: response.selectedFeature,
              lastChangeDate: response.lastChangeDate ? new Date(response.lastChangeDate) : null,
              nextChangeDate: response.nextChangeAvailableDate ? new Date(response.nextChangeAvailableDate) : null,
              canChangeToday: response.canChangeToday,
              changeCount: response.changeCount,
              isLoading: false
            });

            // 使用状況も取得
            if (response.selectedFeature) {
              const usage = await featureSelectionApi.getFeatureUsage(response.selectedFeature);
              set({
                currentUsage: usage.current,
                usageLimits: usage.limits
              });
            }
          } catch (error) {
            set({
              error: error instanceof Error ? error.message : '機能選択情報の取得に失敗しました',
              isLoading: false
            });
          }
        },

        // Select or change feature
        selectFeature: async (feature: string) => {
          set({ isLoading: true, error: null });
          
          try {
            const response = await featureSelectionApi.selectFeature(feature);
            
            if (response.success) {
              set({
                selectedFeature: feature,
                lastChangeDate: new Date(),
                nextChangeDate: new Date(response.nextChangeDate),
                canChangeToday: false,
                changeCount: get().changeCount + 1,
                currentUsage: {},
                isLoading: false
              });
            } else {
              set({
                error: response.message,
                isLoading: false
              });
            }
            
            return response;
          } catch (error) {
            const message = error instanceof Error ? error.message : '機能選択に失敗しました';
            set({
              error: message,
              isLoading: false
            });
            return { success: false, message };
          }
        },

        // Check feature access
        checkFeatureAccess: async (feature: string, action: string) => {
          const state = get();
          
          // 選択されていない機能へのアクセスは拒否
          if (state.selectedFeature !== feature) {
            return false;
          }
          
          // ローカルで使用制限をチェック
          const usageKey = `${feature}.${action}`;
          const currentUsage = state.currentUsage[usageKey] || 0;
          const limit = state.usageLimits[usageKey];
          
          if (limit && currentUsage >= limit) {
            return false;
          }
          
          // サーバー側でも確認
          try {
            const hasAccess = await featureSelectionApi.checkAccess(feature, action);
            return hasAccess;
          } catch {
            return false;
          }
        },

        // Track usage
        trackUsage: (feature: string, action: string) => {
          const usageKey = `${feature}.${action}`;
          set((state) => ({
            currentUsage: {
              ...state.currentUsage,
              [usageKey]: (state.currentUsage[usageKey] || 0) + 1
            }
          }));
          
          // サーバーに使用状況を送信（非同期）
          featureSelectionApi.logUsage(feature, action).catch(console.error);
        },

        // Clear error
        clearError: () => set({ error: null })
      }),
      {
        name: 'feature-selection-storage',
        partialize: (state) => ({
          selectedFeature: state.selectedFeature,
          lastChangeDate: state.lastChangeDate,
          nextChangeDate: state.nextChangeDate
        })
      }
    )
  )
);
```

## 5. セキュリティ考慮事項

### 5.1 アクセス制御
- JWT トークンによる認証
- Store ID の検証
- 機能アクセス権限の確認
- Rate limiting の実装

### 5.2 データ保護
- 個人情報のマスキング
- SQLインジェクション対策
- XSS対策
- CSRF対策

### 5.3 監査ログ
- すべての機能変更を記録
- 使用状況の詳細ログ
- 異常なアクセスパターンの検出

## 6. パフォーマンス最適化

### 6.1 キャッシング戦略
- Redis による機能選択情報のキャッシュ（5分）
- フロントエンド側でのローカルストレージ活用
- API レスポンスのキャッシュ

### 6.2 データベース最適化
- 適切なインデックスの設定
- パーティショニングの検討（ログテーブル）
- 定期的な統計情報更新

### 6.3 フロントエンド最適化
- コンポーネントの遅延読み込み
- 画像の最適化
- バンドルサイズの削減

## 7. テスト戦略

### 7.1 単体テスト
- サービス層のビジネスロジック
- API エンドポイント
- フロントエンドコンポーネント

### 7.2 統合テスト
- API とデータベースの連携
- 機能変更フロー全体
- 使用制限の動作確認

### 7.3 E2Eテスト
- 初回機能選択フロー
- 機能変更フロー
- 使用制限到達時の動作

## 8. 監視とアラート

### 8.1 監視項目
- API レスポンスタイム
- エラー率
- 機能選択/変更の成功率
- 各機能の使用状況

### 8.2 アラート設定
- エラー率が閾値を超えた場合
- レスポンスタイムの劣化
- 異常な使用パターンの検出

---

**最終更新**: 2025年8月24日 19:15  
**次のステップ**: 実装タスクリストの作成と役割分担