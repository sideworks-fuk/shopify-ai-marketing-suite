# インストールページ・初期設定ページ エラー対策

## 作業情報
- 開始日時: 2025-12-29
- 完了日時: 2025-12-29
- 担当: 福田＋AI Assistant

## 問題概要

インストールページ（`/install`）および初期設定ページ（`/setup/initial`）で以下のエラーが多発していました：

1. **Hydrationエラー**: サーバーサイドとクライアントサイドでレンダリング結果が一致しない
2. **401 Unauthorizedエラー**: 認証前のページで`StoreContext`がAPIを呼び出している
3. **ReferenceError**: `DEFAULT_STORES`が未定義（既に修正済み）

## 実施した修正

### 1. `StoreContext.tsx`の修正

**問題**: `/install`ページで認証前にもかかわらず、`StoreContext`が`/api/store`を呼び出していたため、401エラーが発生していた。

**修正内容**:
- `fetchStores`関数内で、`/install`ページまたは`/`ページの場合はAPI呼び出しをスキップするように変更

```typescript
const fetchStores = useCallback(async () => {
  // インストールページまたはルートページでは API 呼び出しをスキップ
  if (typeof window !== 'undefined') {
    const pathname = window.location.pathname
    if (pathname === '/install' || pathname === '/') {
      console.log('📋 インストールページまたはルートページのため、ストア取得をスキップ', { pathname })
      return
    }
  }
  // ... 既存の処理
}, [isDeveloperMode])
```

**効果**:
- `/install`ページでの不要なAPI呼び出しを防止
- 401エラーの発生を防止
- パフォーマンスの向上

---

### 2. `/install/page.tsx`の修正

**問題**: `isDirectAccess`が`null`の初期値で、`useEffect`内で設定されるため、サーバーサイドとクライアントサイドで異なるレンダリング結果が生成され、Hydrationエラーが発生していた。

**修正内容**:
- `suppressHydrationWarning`の使用をやめ、条件付きレンダリングを遅延させる方法に変更
- `isMounted`状態を追加し、クライアントサイドでのみレンダリングするように変更

```typescript
const [isMounted, setIsMounted] = useState(false)

// クライアントサイドマウント状態を設定（Hydrationエラー対策）
useEffect(() => {
  setIsMounted(true)
}, [])

// クライアントサイドでのみレンダリング（Hydrationエラー対策）
if (!isMounted) {
  return (
    <div style={{ backgroundColor: '#F6F6F7', minHeight: '100vh', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
      <div style={{ textAlign: 'center' }}>
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
        <p className="text-gray-600 font-medium">読み込み中...</p>
      </div>
    </div>
  )
}
```

**効果**:
- Hydrationエラーの解消
- サーバーサイドとクライアントサイドで一貫したレンダリング結果
- より安全な実装

---

## 修正前後の比較

### 修正前

**問題点**:
- `StoreContext`が`/install`ページでもAPIを呼び出していた
- `suppressHydrationWarning`を使用していたが、根本的な解決になっていなかった
- 401エラーが多発していた

**エラー例**:
```
GET https://localhost:7088/api/store 401 (Unauthorized)
ストア一覧取得エラー: Error: ストア一覧の取得に失敗しました
Hydration failed because the initial UI does not match what was rendered on the server
```

### 修正後

**改善点**:
- `/install`ページではAPI呼び出しをスキップ
- 条件付きレンダリングを遅延させることで、Hydrationエラーを根本的に解決
- 401エラーの発生を防止

**期待される結果**:
- `/install`ページでのエラーが解消
- パフォーマンスの向上
- ユーザー体験の改善

---

## 確認事項

### 1. `/install`ページでの動作確認

- [ ] Hydrationエラーが発生していないか
- [ ] 401エラーが発生していないか
- [ ] ページが正常に表示されるか
- [ ] ブラウザのコンソールにエラーが表示されていないか

### 2. その他のページでの動作確認

- [ ] 通常のページ（`/customers/dormant`など）で`StoreContext`が正常に動作しているか
- [ ] ストア一覧が正しく取得できているか
- [ ] ストア切り替えが正常に動作しているか

---

## 技術的な詳細

### Hydrationエラーの原因

1. **サーバーサイドレンダリング（SSR）**: Next.jsはサーバーサイドでHTMLを生成
2. **クライアントサイドレンダリング（CSR）**: ブラウザでJavaScriptが実行され、ReactがDOMを更新
3. **不一致**: サーバーサイドとクライアントサイドで生成されるHTMLが異なる場合、Hydrationエラーが発生

### 解決方法

**推奨される方法**: 条件付きレンダリングを遅延させる
- `isMounted`状態を使用して、クライアントサイドでのみレンダリング
- サーバーサイドでは最小限のローディング画面を表示
- クライアントサイドでマウント後に完全なUIを表示

**非推奨**: `suppressHydrationWarning`の使用
- 警告を抑制するだけで、根本的な解決にならない
- 他の問題を隠す可能性がある

---

## 関連ファイル

- `frontend/src/contexts/StoreContext.tsx`: API呼び出しのスキップ処理を追加
- `frontend/src/app/install/page.tsx`: 条件付きレンダリングを遅延させる処理を追加
- `frontend/src/app/setup/initial/page.tsx`: 条件付きレンダリングを遅延させる処理を追加
- `frontend/src/app/page.tsx`: OAuth認証完了フラグの確認処理を追加

---

## 追加修正: ルートページ（`/`）の401エラー対策

### 問題

ルートページで以下の問題が発生していました：

1. **`isAuthenticated: true`（セッショントークン取得済み）だが、OAuth認証が未完了**
2. **バックエンドAPI呼び出しで401エラーが発生**
3. **最終的には正しくインストールページへリダイレクトされているが、不要な401エラーが表示される**

**ログ例**:
```
認証の初期化が完了しました {authMode: 'shopify', isEmbedded: true, oauthAuthenticated: null, finalAuthState: false}
↓
[ルートページ] 認証状態をチェック: {isAuthenticated: true, ...}  ← セッショントークンがあるのでtrue
↓
[ルートページ] ストアの存在を確認中...
↓
GET https://localhost:7088/api/store 401 (Unauthorized)  ← OAuth未完了なので401
↓
[ルートページ] インストールページへリダイレクト: /install?shop=...  ← 最終的には正しい
```

### 修正内容

ルートページでOAuth認証完了フラグ（`oauth_authenticated`）を確認してからストアAPIを呼び出すように修正しました。

```typescript
if (isAuthenticated) {
  // デモトークンが存在する場合は、デモモード専用のリダイレクトロジックを適用
  const demoToken = typeof window !== 'undefined' ? localStorage.getItem('demoToken') || localStorage.getItem('demo_token') : null
  const authMode = typeof window !== 'undefined' ? localStorage.getItem('authMode') : null
  const oauthAuthenticated = typeof window !== 'undefined' ? localStorage.getItem('oauth_authenticated') : null
  
  if (demoToken && authMode === 'demo') {
    // デモモードの場合、ストア確認をスキップしてデモモード専用のダッシュボードにリダイレクト
    // ... 既存のコード
  }
  
  // 🆕 Shopify埋め込みモードでOAuth未完了の場合は、ストアAPIを呼び出さずにインストールページへ
  if (shop && oauthAuthenticated !== 'true') {
    console.log('⚠️ [ルートページ] Shopify埋め込みモードでOAuth未完了: インストールページへリダイレクト', {
      shop,
      oauthAuthenticated,
      isAuthenticated
    })
    const redirectUrl = buildRedirectUrl('/install')
    setStatusMessage('インストールページへ移動中...')
    router.replace(redirectUrl)
    return
  }
  
  // OAuth認証済みの場合のみ、ストアの存在を確認
  setStatusMessage('ストア情報を確認中...')
  // ... 既存のコード
}
```

**効果**:
- 不要な401エラーの発生を防止
- OAuth未完了の場合は、ストアAPIを呼び出さずに直接インストールページへリダイレクト
- パフォーマンスの向上（不要なAPI呼び出しの削減）
- ユーザー体験の改善（エラー画面の表示を防止）

---

## 追加修正: `/setup/initial`ページ

### 問題

`/setup/initial`ページでも同様のHydrationエラーが発生していました。

### 修正内容

`/install`ページと同様に、`isMounted`状態を追加し、クライアントサイドでのみレンダリングするように変更しました。

```typescript
const [isMounted, setIsMounted] = useState(false)

// クライアントサイドマウント状態を設定（Hydrationエラー対策）
useEffect(() => {
  setIsMounted(true)
  if (typeof window !== 'undefined') {
    const demoToken = localStorage.getItem('demoToken')
    setIsDemoMode(!!demoToken)
  }
}, [])

// クライアントサイドでのみレンダリング（Hydrationエラー対策）
if (!isMounted) {
  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-50 to-gray-100 flex items-center justify-center">
      <div className="text-center">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
        <p className="text-gray-600 font-medium">読み込み中...</p>
      </div>
    </div>
  )
}
```

**効果**:
- `/setup/initial`ページでのHydrationエラーの解消
- `isDemoMode`の設定を`useEffect`内で行うことで、サーバーサイドとクライアントサイドで一貫したレンダリング結果

---

## 追加修正: ルートページ（`/`）のHydrationエラー対策

### 問題

ルートページでも同様のHydrationエラーが発生していました。

### 修正内容

`/install`ページと同様に、`isMounted`状態を追加し、クライアントサイドでのみレンダリングするように変更しました。

```typescript
const [isMounted, setIsMounted] = useState(false)

// クライアントサイドマウント状態を設定（Hydrationエラー対策）
useEffect(() => {
  setIsMounted(true)
}, [])

// クライアントサイドでのみレンダリング（Hydrationエラー対策）
if (!isMounted) {
  return (
    <div className="min-h-screen bg-gray-50 flex items-center justify-center">
      <div className="text-center">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto"></div>
        <p className="mt-2 text-gray-600">アプリケーションを初期化中...</p>
      </div>
    </div>
  )
}
```

**効果**:
- ルートページでのHydrationエラーの解消
- `statusMessage`の設定を`useEffect`内で行うことで、サーバーサイドとクライアントサイドで一貫したレンダリング結果
- `suppressHydrationWarning`の使用をやめ、より安全な実装に変更

---

## 追加修正: ConditionalLayoutのHydrationエラー対策

### 問題

`ConditionalLayout`が`useIsEmbedded()`フックを使用していますが、このフックは`useState(false)`で初期化され、`useEffect`内で値を更新するため、サーバーサイドとクライアントサイドで異なる結果を生成する可能性がありました。

### 修正内容

`ConditionalLayout`に`isMounted`状態を追加し、クライアントサイドマウント前はレイアウトなしでchildrenを返すように変更しました。

```typescript
const [isMounted, setIsMounted] = useState(false)

// クライアントサイドマウント状態を設定（Hydrationエラー対策）
useEffect(() => {
  setIsMounted(true)
}, [])

// クライアントサイドマウント前は、レイアウトなしでchildrenを返す（Hydrationエラー対策）
if (!isMounted) {
  return <>{children}</>
}
```

**効果**:
- `ConditionalLayout`でのHydrationエラーの解消
- `useIsEmbedded()`の値が`useEffect`内で更新される前にレイアウトを決定することで、サーバーサイドとクライアントサイドで一貫したレンダリング結果

---

## 追加修正: /install/layout.tsxの'use client'ディレクティブ追加

### 問題

`/install/layout.tsx`に`'use client'`ディレクティブがないため、`PolarisProvider`がサーバーサイドでもレンダリングされようとしていました。`PolarisProvider`は`'use client'`ディレクティブを持つクライアントコンポーネントのため、サーバーサイドでレンダリングしようとするとHydrationエラーが発生します。

### 修正内容

`/install/layout.tsx`の先頭に`'use client'`ディレクティブを追加しました。

```typescript
'use client';  // ← 追加

import { PolarisProvider } from '@/components/providers/PolarisProvider';

export default function InstallLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <PolarisProvider>
      {children}
    </PolarisProvider>
  );
}
```

**効果**:
- `/install`ページでのHydrationエラーの解消
- `PolarisProvider`がクライアントサイドでのみレンダリングされるようになり、サーバーサイドとクライアントサイドで一貫したレンダリング結果

---

## 追加修正: /install/page.tsxのHydrationエラー対策（ローディング画面とisDirectAccess）

### 問題

1. `isMounted`が`false`の場合のローディング画面が、Polarisコンポーネントを使用していないため、サーバーサイドとクライアントサイドで異なる構造が返されていました。
2. `isDirectAccess`の初期値が`null`のため、サーバーサイドとクライアントサイドで異なる初期値が使用されていました。

### 修正内容

1. **ローディング画面をPolarisコンポーネントで統一**:
   - `isMounted`が`false`の場合も、Polarisコンポーネント（`Page`, `Box`, `BlockStack`, `Text`）を使用した構造に変更しました。
   - これにより、サーバーサイドとクライアントサイドで同じ構造が返されるようになります。

2. **`isDirectAccess`の初期値を`false`に変更**:
   - `useState<boolean | null>(null)`から`useState<boolean>(false)`に変更しました。
   - これにより、サーバーサイドとクライアントサイドで同じ初期値が使用されるようになります。

```typescript
// 修正前
const [isDirectAccess, setIsDirectAccess] = useState<boolean | null>(null);

// 修正後
const [isDirectAccess, setIsDirectAccess] = useState<boolean>(false);

// ローディング画面もPolarisコンポーネントを使用
if (!isMounted) {
  return (
    <div style={{ backgroundColor: '#F6F6F7', minHeight: '100vh' }}>
      <Box padding="800">
        <div style={{ maxWidth: '600px', margin: '0 auto' }}>
          <Page narrowWidth>
            <BlockStack gap="800">
              <div style={{ textAlign: 'center', padding: '40px 0' }}>
                <Box padding="400">
                  <Text as="p" variant="bodyLg" alignment="center">
                    読み込み中...
                  </Text>
                </Box>
              </div>
            </BlockStack>
          </Page>
        </div>
      </Box>
    </div>
  )
}
```

**効果**:
- `/install`ページでのHydrationエラーの解消
- サーバーサイドとクライアントサイドで同じ構造と初期値が使用されるようになり、一貫したレンダリング結果

---

## 追加修正: /install/page.tsxのローディング画面を最小限のHTML構造に変更

### 問題

`isMounted`が`false`の場合のローディング画面でPolarisコンポーネント（`Box`, `Page`, `BlockStack`, `Text`）を使用していましたが、サーバーサイドでは`PolarisProvider`がまだ初期化されていない可能性があり、Hydrationエラーが発生していました。

### 修正内容

`isMounted`が`false`の場合のローディング画面を、Polarisコンポーネントを使用しない最小限のHTML構造に変更しました。Tailwindの`animate-spin`クラスを使用して、ローディングスピナーを表示します。

```typescript
// 修正前（Polarisコンポーネントを使用）
if (!isMounted) {
  return (
    <div style={{ backgroundColor: '#F6F6F7', minHeight: '100vh' }}>
      <Box padding="800">
        <div style={{ maxWidth: '600px', margin: '0 auto' }}>
          <Page narrowWidth>
            <BlockStack gap="800">
              <div style={{ textAlign: 'center', padding: '40px 0' }}>
                <Box padding="400">
                  <Text as="p" variant="bodyLg" alignment="center">
                    読み込み中...
                  </Text>
                </Box>
              </div>
            </BlockStack>
          </Page>
        </div>
      </Box>
    </div>
  )
}

// 修正後（最小限のHTML構造）
if (!isMounted) {
  return (
    <div style={{ backgroundColor: '#F6F6F7', minHeight: '100vh', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
      <div style={{ textAlign: 'center' }}>
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
        <p className="text-gray-600 font-medium">読み込み中...</p>
      </div>
    </div>
  )
}
```

**効果**:
- `/install`ページでのHydrationエラーの解消
- Polarisコンポーネントを使用しないため、`PolarisProvider`の初期化状態に依存しない
- サーバーサイドとクライアントサイドで同じ構造が返されるようになり、一貫したレンダリング結果

---

## 追加修正: デバッグ情報セクションのHydrationエラー対策

### 問題

デバッグ情報セクションで`getCurrentEnvironmentConfig()`を使用していましたが、この関数は`getCurrentEnvironment()`内で`localStorage`を参照するため、サーバーサイドとクライアントサイドで異なる値を返す可能性がありました。

- サーバーサイド: `localStorage`にアクセスできないため、環境変数に基づいて環境を決定
- クライアントサイド: `localStorage.getItem('selectedEnvironment')`をチェックするため、異なる値を返す可能性

### 修正内容

デバッグ情報セクションを`isMounted`が`true`の場合のみ表示するように変更しました。これにより、サーバーサイドでは表示されず、クライアントサイドでのみ表示されるため、Hydrationエラーが解消されます。

```typescript
// 修正前
{process.env.NODE_ENV === 'development' && (
  <Card>
    {/* ... */}
    <div>環境: {getCurrentEnvironmentConfig().name}</div>
    <div>API URL: {getCurrentEnvironmentConfig().apiBaseUrl}</div>
    {/* ... */}
  </Card>
)}

// 修正後
{/* isMountedがtrueの場合のみ表示（Hydrationエラー対策：getCurrentEnvironmentConfig()がサーバー/クライアントで異なる値を返す可能性があるため） */}
{isMounted && process.env.NODE_ENV === 'development' && (
  <Card>
    {/* ... */}
    <div>環境: {getCurrentEnvironmentConfig().name}</div>
    <div>API URL: {getCurrentEnvironmentConfig().apiBaseUrl}</div>
    {/* ... */}
  </Card>
)}
```

**効果**:
- デバッグ情報セクションでのHydrationエラーの解消
- サーバーサイドでは表示されず、クライアントサイドでのみ表示されるため、`getCurrentEnvironmentConfig()`が異なる値を返しても問題にならない

---

## 追加修正: useSearchParams()のSuspenseラップ

### 問題

`useSearchParams()`を使用しているため、Suspense boundaryでHydrationエラーが発生していました。`layout.tsx`で`Suspense`でラップされていますが、`useSearchParams()`を使用するコンポーネント自体を`Suspense`でラップする必要があります。

### 修正内容

`useSearchParams()`を使用するコンポーネントを`Suspense`でラップしました。これにより、Suspense boundaryでのHydrationエラーが解消されます。

```typescript
// 修正前
export default function InstallPolarisPage() {
  const searchParams = useSearchParams(); // URLパラメータを取得
  // ...
}

// 修正後
function InstallPolarisPageContent() {
  const searchParams = useSearchParams(); // URLパラメータを取得
  // ...
}

export default function InstallPolarisPage() {
  return (
    <Suspense fallback={
      <div style={{ backgroundColor: '#F6F6F7', minHeight: '100vh', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
        <div style={{ textAlign: 'center' }}>
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
          <p className="text-gray-600 font-medium">読み込み中...</p>
        </div>
      </div>
    }>
      <InstallPolarisPageContent />
    </Suspense>
  );
}
```

**効果**:
- Suspense boundaryでのHydrationエラーの解消
- `useSearchParams()`を使用するコンポーネントが適切に`Suspense`でラップされることで、サーバーサイドとクライアントサイドで一貫したレンダリング結果

---

## 追加修正: ZustandProviderのローディング画面スキップ

### 問題

`ZustandProvider`が初期化中にローディング画面を表示しているため、`/install`ページにリダイレクトした後も、再度ローディング画面が表示され、以下のような動作になっていました：

1. アプリケーションを初期化中... ← ルートページ（`/`）
2. インストールページへ移動中... ← ルートページからリダイレクト
3. インストールページ（1回目） ← `/install`表示
4. アプリケーションを初期化中... ← `ZustandProvider`のローディング画面が再度表示
5. インストールページ（2回目） ← 2回目のレンダリング + Hydrationエラー

### 修正内容

`ZustandProvider`で、`/install`などの特定のページではローディング画面をスキップするように変更しました。

```typescript
// 修正後
export function ZustandProvider({ children }: ZustandProviderProps) {
  const pathname = usePathname()
  
  // ローディング画面をスキップするページのパスを定義
  const skipLoadingPaths = [
    '/',
    '/install',
    '/auth/success',
    '/auth/callback',
    '/auth/select',
    '/demo/login',
    '/terms',
    '/privacy'
  ]
  
  // 現在のパスがskipLoadingPathsに含まれているかチェック
  const shouldSkipLoading = pathname ? skipLoadingPaths.some(path => {
    if (path === '/') {
      return pathname === '/'
    }
    return pathname.startsWith(path)
  }) : false
  
  // セッション内でハイドレーション完了状態を保持（ページ遷移後も再表示しない）
  const [isHydrated, setIsHydrated] = useState(() => {
    if (typeof window === 'undefined') return false
    // セッション内で既にハイドレーション完了している場合は即座にtrue
    // または、ローディングをスキップするページの場合は即座にtrue
    return sessionStorage.getItem('zustand_hydrated') === 'true' || shouldSkipLoading
  })
  
  // ハイドレーション完了前は最小限のUIを表示
  // ただし、ローディングをスキップするページの場合はスキップ
  if (!isHydrated && !shouldSkipLoading) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center" suppressHydrationWarning>
        <div className="text-center" suppressHydrationWarning>
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto" suppressHydrationWarning></div>
          <p className="mt-2 text-gray-600" suppressHydrationWarning>アプリケーションを初期化中...</p>
        </div>
      </div>
    )
  }
  
  return <>{children}</>
}
```

**効果**:
- `/install`ページに直接アクセスした場合や、ルートページからリダイレクトした場合でも、ローディング画面が表示されなくなる
- 2回目のレンダリングとHydrationエラーが解消される
- ページ遷移がスムーズになる

---

## ✅ 修正完了

### 結果

**Hydrationエラーが解消されました** ✅

### 実施した修正のまとめ

1. **ルートページ（`/`）のHydrationエラー対策**
   - `isMounted`状態を追加し、クライアントサイドでのみレンダリングするように変更

2. **`/install/layout.tsx`の`'use client'`ディレクティブ追加**
   - `PolarisProvider`がサーバーサイドでレンダリングされないように修正

3. **`/install/page.tsx`のローディング画面を最小限のHTML構造に変更**
   - Polarisコンポーネントを使用しない最小限のHTML構造に変更

4. **`/install/page.tsx`の`isDirectAccess`の初期値を`false`に変更**
   - サーバーサイドとクライアントサイドで同じ初期値を使用

5. **`/install/page.tsx`のデバッグ情報セクションを`isMounted`が`true`の場合のみ表示**
   - `getCurrentEnvironmentConfig()`がサーバー/クライアントで異なる値を返す可能性があるため

6. **`/install/page.tsx`の`useSearchParams()`を`Suspense`でラップ**
   - Suspense boundaryでのHydrationエラーを解消

7. **`ConditionalLayout`のHydrationエラー対策**
   - `isMounted`状態を追加し、クライアントサイドマウント前はレイアウトなしでchildrenを返すように変更

8. **`ZustandProvider`のローディング画面スキップ**
   - `/install`などの特定のページではローディング画面をスキップするように変更

### 修正ファイル一覧

- `frontend/src/app/page.tsx`
- `frontend/src/app/install/layout.tsx`
- `frontend/src/app/install/page.tsx`
- `frontend/src/components/layout/ConditionalLayout.tsx`
- `frontend/src/components/providers/ZustandProvider.tsx`

---

## 追加修正: checkAndRedirect関数の重複実行防止

### 問題

`hasCheckedStoreRef.current = true`の設定が非同期処理の完了前に行われていないため、`useEffect`が再実行されるたびにチェックが走っていました。

**症状**:
- 「登録済みストアをチェック中...」のログが3回出力される
- `useEffect`が3回実行されている
- API呼び出しが途中で失敗/中断される可能性

### 修正内容

`checkAndRedirect`関数を修正し、以下の改善を実施しました：

1. **関数の最初でフラグをチェックして即座にreturn**
2. **チェック開始時にフラグを設定（非同期処理の前に設定）**
3. **待機が必要な場合のみフラグをリセット**
4. **エラー時もフラグはtrueのままにする（無限ループ防止）**

```typescript
const checkAndRedirect = async () => {
  // 🆕 最初にフラグをチェックして即座にreturn
  if (hasCheckedStoreRef.current) {
    console.log('⏸️ 既にストアチェック済みのため、スキップします');
    return;
  }
  
  // 🆕 チェック開始時にフラグを設定（非同期処理の前に設定）
  hasCheckedStoreRef.current = true;
  
  // インストール処理中の場合はスキップ
  if (loading || isInstallingRef.current) {
    console.log('⏳ インストール処理中のため、自動リダイレクトをスキップします。');
    hasCheckedStoreRef.current = false; // リセットして再チェック可能に
    return;
  }

  // 認証状態の初期化を待つ
  if (isInitializing) {
    console.log('⏳ 認証状態の初期化を待機中...');
    hasCheckedStoreRef.current = false; // リセットして再チェック可能に
    return;
  }

  // 未認証の場合はスキップ
  if (!isAuthenticated) {
    console.log('⚠️ 未認証のため、登録済みストアチェックをスキップしてインストール画面を表示します。');
    // hasCheckedStoreRef.current = true; ← 既に設定済みなので不要
    return;
  }

  // 認証済みの場合のみ、登録済みストアチェックを実行
  try {
    console.log('🔍 登録済みストアをチェック中...', { shop: normalizedShop, isAuthenticated });
    // ... 既存の処理
  } catch (error) {
    console.error('❌ 登録済みストアのチェック中にエラーが発生:', error);
    // エラー時もフラグはtrueのままにする（無限ループ防止）
  }
};
```

**効果**:
- `useEffect`の重複実行が防止される
- API呼び出しが1回だけ実行される
- 待機が必要な場合（`loading`、`isInitializing`）のみフラグをリセットし、再チェック可能にする
- エラー時も無限ループを防止

---

## 参考情報

- [Next.js - Hydration Error](https://nextjs.org/docs/messages/react-hydration-error)
- [React - Hydration](https://react.dev/reference/react-dom/client/hydrateRoot)

---

## 更新履歴

- 2025-12-29: 初版作成
