# Shopify API バッチ処理システム - 基本設計書

## 1. 概要

### 1.1 目的
Shopify APIからデータを定期的に取得し、システムのデータベースに同期するバッチ処理システムの設計

### 1.2 対象範囲
- Shopify API統合
- データ同期バッチ処理
- エラーハンドリング・リトライ機能
- ログ・監視機能

## 2. 現状分析

### 2.1 既存アーキテクチャ
```
現在のシステム構成:
├── ShopifyTestApi (.NET 8 Web API)
│   ├── Entity Framework Core
│   ├── Azure SQL Database
│   ├── ApplicationInsights監視
│   └── Serilogロギング
└── ShopifyDataAnonymizer (Console Application)
    ├── CSV処理
    ├── データ匿名化
    └── データベース取り込み
```

### 2.2 データモデル
既存のデータベースモデルが完備:
- `Store` (マルチストア対応)
- `Customer` (Shopify Customer ID対応)
- `Product` + `ProductVariant`
- `Order` + `OrderItem`

## 3. アーキテクチャオプション

### 3.1 オプション1: Azure Functions (推奨)
**メリット:**
- サーバーレス、スケーラビリティ
- コスト効率（使用時のみ課金）
- Azure統合サービス活用
- 独立したデプロイ・監視

**デメリット:**
- 新しいプロジェクト作成が必要
- Cold Start問題
- 実行時間制限（最大10分）

**構成:**
```
ShopifyBatchProcessor (Azure Functions)
├── TimerTrigger (定期実行)
├── HttpTrigger (手動実行)
├── ShopifyApiClient
├── DataSyncService
└── 共通ライブラリ参照
```

### 3.2 オプション2: HangFire統合
**メリット:**
- 既存プロジェクトに統合
- Web管理画面
- 複雑なジョブスケジュール

**デメリット:**
- APIサーバーのリソース消費
- スケーラビリティ制限
- 障害時の影響範囲が広い

### 3.3 オプション3: 新規コンソールアプリ + Windows Service
**メリット:**
- シンプルな構造
- 既存パターンと一致

**デメリット:**
- インフラ管理が必要
- スケーラビリティ制限
- 監視・運用が複雑

## 4. 推奨アーキテクチャ

### 4.1 選択理由
**Azure Functions を推奨**
- Azure環境との親和性
- コスト効率
- 独立した障害対応
- スケーラビリティ

### 4.2 システム構成図
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Shopify API   │◄───│ Azure Functions │────► Azure SQL DB   │
└─────────────────┘    │ Batch Processor │    └─────────────────┘
                       └─────────────────┘           ▲
                              │                      │
                              ▼                      │
                       ┌─────────────────┐           │
                       │ Application     │           │
                       │ Insights        │           │
                       └─────────────────┘           │
                                                     │
                       ┌─────────────────┐           │
                       │ ShopifyTestApi  │───────────┘
                       │ (Web API)       │
                       └─────────────────┘
```

## 5. 機能要件

### 5.1 コア機能
1. **データ同期**
   - 顧客データ同期
   - 商品データ同期
   - 注文データ同期
   - 増分同期対応

2. **スケジューリング**
   - 定期実行（例: 1時間毎）
   - 手動実行機能
   - 優先度制御

3. **エラーハンドリング**
   - APIレート制限対応
   - リトライ機能
   - デッドレター処理

### 5.2 監視・ログ機能
1. **ログ出力**
   - 処理開始/終了
   - エラー詳細
   - 処理件数・時間

2. **監視**
   - Application Insights統合
   - アラート機能
   - ダッシュボード

## 6. 非機能要件

### 6.1 パフォーマンス
- 1万件の顧客データを5分以内で処理
- Shopify APIレート制限遵守（2req/sec）
- 並列処理による効率化

### 6.2 可用性
- 99.9%の処理成功率
- 障害時の自動リトライ
- データ整合性保証

### 6.3 セキュリティ
- Shopify APIトークン安全管理
- Azure Key Vault統合
- 監査ログ出力

## 7. データフロー

### 7.1 基本フロー
```
1. Timer Trigger実行
2. 前回同期時刻取得
3. Shopify API呼び出し
   - GET /admin/api/2023-10/customers.json
   - GET /admin/api/2023-10/products.json
   - GET /admin/api/2023-10/orders.json
4. データ変換・マッピング
5. データベース更新
6. 同期時刻更新
7. ログ出力
```

### 7.2 エラーハンドリングフロー
```
1. API呼び出し失敗検知
2. エラー種別判定
   - Rate Limit → 待機後リトライ
   - Network Error → 指数バックオフでリトライ
   - Data Error → スキップ + ログ出力
3. 最大リトライ回数超過時
   - Dead Letter送信
   - アラート通知
```

## 8. 実装方針

### 8.1 プロジェクト構成
新規Azure Functionsプロジェクトを作成し、既存の共通ライブラリを参照

### 8.2 共通化
- データモデル共有
- データベースアクセス共有
- ログ設定共有

### 8.3 段階的実装
1. **Phase 1**: 顧客データ同期
2. **Phase 2**: 商品データ同期
3. **Phase 3**: 注文データ同期
4. **Phase 4**: 高度な機能（並列処理、増分同期）

## 9. 運用考慮事項

### 9.1 監視ポイント
- 処理成功率
- 処理時間
- APIレート制限状況
- データベース性能

### 9.2 保守性
- 設定の外部化
- ログレベル調整
- デバッグ機能

## 10. 次ステップ

1. 詳細設計書作成
2. Shopify API調査・検証
3. プロトタイプ開発
4. 段階的実装