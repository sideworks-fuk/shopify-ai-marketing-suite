# デバッグエンドポイント保護方法

**作成日**: 2025-01-23  
**目的**: デバッグエンドポイントを本番環境で保護する方法を検討

## 現在の認証システム

### 利用可能な認証方式

1. **Shopify OAuth認証**（本番環境）
   - Shopify App Bridgeセッショントークン
   - OAuth認証済みユーザー

2. **デモモード認証**（開発環境）
   - `/api/demo/login` でログイン
   - デモ用トークン

3. **開発者認証**（開発環境のみ）
   - `/api/developer/login` でログイン
   - `can_access_dev_tools` クレームが付与される
   - 開発環境でのみ有効

4. **ロールベース認証**
   - `[Authorize(Roles = "Administrator")]` が使用されている
   - ただし、ロール管理システムの実装状況は要確認

---

## 保護方法の選択肢

### 方法1: 環境変数による制御（推奨・最も簡単）

**実装**: 開発環境のみでエンドポイントを有効化

**メリット**:
- 実装が簡単
- 本番環境では完全に無効化される
- 追加の認証不要

**デメリット**:
- 本番環境でデバッグが必要な場合に使用できない

**実装例**:
```csharp
#if DEBUG
[HttpGet("debug-stores")]
[AllowAnonymous]
public async Task<IActionResult> DebugStores(...)
{
    // デバッグ処理
}
#endif
```

または

```csharp
[HttpGet("debug-stores")]
public async Task<IActionResult> DebugStores(...)
{
    if (!_env.IsDevelopment())
    {
        return NotFound(); // 本番環境では404を返す
    }
    // デバッグ処理
}
```

---

### 方法2: 開発者認証を必須にする

**実装**: `can_access_dev_tools` クレームをチェックするカスタム属性を作成

**メリット**:
- 本番環境でも開発者がアクセス可能
- 既存の開発者認証システムを活用

**デメリット**:
- 開発者認証が本番環境で有効になっている必要がある
- カスタム属性の実装が必要

**実装例**:
```csharp
// カスタム認証属性
public class RequireDeveloperAuthAttribute : Attribute, IAuthorizationFilter
{
    public void OnAuthorization(AuthorizationFilterContext context)
    {
        var user = context.HttpContext.User;
        var hasDevToolsClaim = user.HasClaim("can_access_dev_tools", "true");
        var isDevelopment = context.HttpContext.RequestServices
            .GetRequiredService<IHostEnvironment>().IsDevelopment();

        if (!hasDevToolsClaim && !isDevelopment)
        {
            context.Result = new UnauthorizedResult();
        }
    }
}

// 使用例
[HttpGet("debug-stores")]
[RequireDeveloperAuth]
public async Task<IActionResult> DebugStores(...)
{
    // デバッグ処理
}
```

---

### 方法3: ロールベース認証（管理者ロール）

**実装**: `[Authorize(Roles = "Administrator")]` を使用

**メリット**:
- ASP.NET Core標準の認証システムを使用
- 既に`DatabaseController`で使用されている

**デメリット**:
- 管理者ロールの実装が必要（現在は未確認）
- ロール管理システムの実装が必要

**実装例**:
```csharp
[HttpGet("debug-stores")]
[Authorize(Roles = "Administrator")]
public async Task<IActionResult> DebugStores(...)
{
    // デバッグ処理
}
```

**注意**: 現在、`[Authorize(Roles = "Administrator")]`が使用されているが、実際のロール管理システムが実装されているか確認が必要です。

---

### 方法4: IPアドレス制限

**実装**: 特定のIPアドレスからのみアクセス可能にする

**メリット**:
- シンプルな実装
- 外部からのアクセスを完全にブロック

**デメリット**:
- IPアドレスの管理が必要
- 動的IPアドレスの場合、管理が困難

**実装例**:
```csharp
[HttpGet("debug-stores")]
public async Task<IActionResult> DebugStores(...)
{
    var allowedIPs = _configuration.GetSection("Debug:AllowedIPs").Get<string[]>();
    var clientIP = HttpContext.Connection.RemoteIpAddress?.ToString();
    
    if (allowedIPs == null || !allowedIPs.Contains(clientIP))
    {
        return Unauthorized();
    }
    // デバッグ処理
}
```

---

### 方法5: API Key認証

**実装**: カスタムAPI Keyを要求する

**メリット**:
- シンプルな実装
- 外部ツールからもアクセス可能

**デメリット**:
- API Keyの管理が必要
- 追加の認証システムが必要

**実装例**:
```csharp
[HttpGet("debug-stores")]
public async Task<IActionResult> DebugStores([FromHeader] string? X-Debug-Api-Key)
{
    var validApiKey = _configuration["Debug:ApiKey"];
    if (string.IsNullOrEmpty(X-Debug-Api-Key) || X-Debug-Api-Key != validApiKey)
    {
        return Unauthorized();
    }
    // デバッグ処理
}
```

---

## 推奨実装方針

### 段階的なアプローチ

#### フェーズ1: 即座に対応（最高危険度エンドポイント）

**対象**:
- `/api/shopify/test-settings` - ApiKey/ApiSecretを返す
- `/api/shopify/debug-shopify-apps` - ApiKeyFullを返す
- `/api/shopify/debug-stores` - AccessTokenプレビューを返す

**対策**: **方法1（環境変数による制御）**を推奨
- 本番環境では完全に無効化
- 実装が簡単で確実

#### フェーズ2: 高危険度エンドポイント

**対象**:
- `/api/debug/segment-analysis`
- `/api/hangfire/test-job`
- `/api/shopify/test-encryption`
- `/api/shopify/test-oauth-url`
- `/api/shopify/test-config`

**対策**: **方法1（環境変数による制御）**または**方法2（開発者認証）**

---

## 実装例

### 例1: 環境変数による制御（推奨）

```csharp
// backend/ShopifyAnalyticsApi/Controllers/ShopifyAuthController.cs

[HttpGet("debug-stores")]
public async Task<IActionResult> DebugStores([FromQuery] string? shop = null)
{
    // 本番環境では404を返す
    if (!_env.IsDevelopment())
    {
        return NotFound();
    }

    try
    {
        // デバッグ処理
        // ...
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Storeテーブル確認中にエラーが発生");
        return StatusCode(500, new { error = "Failed to query Store table", details = ex.Message });
    }
}
```

### 例2: 開発者認証を必須にする

```csharp
// カスタム認証属性を作成
// backend/ShopifyAnalyticsApi/Attributes/RequireDeveloperAuthAttribute.cs

using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.Filters;
using Microsoft.Extensions.DependencyInjection;

namespace ShopifyAnalyticsApi.Attributes
{
    /// <summary>
    /// 開発者認証を必須にする属性
    /// 開発環境では自動的に許可、本番環境では開発者認証が必要
    /// </summary>
    public class RequireDeveloperAuthAttribute : Attribute, IAuthorizationFilter
    {
        public void OnAuthorization(AuthorizationFilterContext context)
        {
            var env = context.HttpContext.RequestServices.GetRequiredService<IHostEnvironment>();
            
            // 開発環境では自動的に許可
            if (env.IsDevelopment())
            {
                return;
            }

            // 本番環境では開発者認証が必要
            var user = context.HttpContext.User;
            var hasDevToolsClaim = user.HasClaim("can_access_dev_tools", "true");
            
            if (!hasDevToolsClaim)
            {
                context.Result = new UnauthorizedObjectResult(new
                {
                    error = "Unauthorized",
                    message = "Developer authentication required for this endpoint"
                });
            }
        }
    }
}

// 使用例
[HttpGet("debug-stores")]
[RequireDeveloperAuth]
public async Task<IActionResult> DebugStores([FromQuery] string? shop = null)
{
    // デバッグ処理
}
```

### 例3: 条件付きコンパイル

```csharp
#if DEBUG
[HttpGet("debug-stores")]
[AllowAnonymous]
public async Task<IActionResult> DebugStores([FromQuery] string? shop = null)
{
    // デバッグ処理
}
#endif
```

---

## 実装チェックリスト

### 即座に対応が必要（最高危険度）

- [ ] `/api/shopify/test-settings` を環境変数で制御
- [ ] `/api/shopify/debug-shopify-apps` の`ApiKeyFull`を削除、または環境変数で制御
- [ ] `/api/shopify/debug-stores` を環境変数で制御

### 推奨対応（高危険度）

- [ ] `/api/debug/segment-analysis` を環境変数で制御
- [ ] `/api/hangfire/test-job` を環境変数で制御
- [ ] `/api/shopify/test-encryption` を環境変数で制御
- [ ] `/api/shopify/test-oauth-url` を環境変数で制御
- [ ] `/api/shopify/test-config` を環境変数で制御

---

## 結論

**推奨**: **方法1（環境変数による制御）**

**理由**:
1. 実装が最も簡単
2. 本番環境では完全に無効化される
3. 追加の認証システムが不要
4. セキュリティリスクが最小

**代替案**: 本番環境でもデバッグが必要な場合は、**方法2（開発者認証）**を検討

---

## 参考

- [ASP.NET Core 認証と承認](https://learn.microsoft.com/ja-jp/aspnet/core/security/authentication/)
- [環境変数の使用](https://learn.microsoft.com/ja-jp/aspnet/core/fundamentals/environments)

