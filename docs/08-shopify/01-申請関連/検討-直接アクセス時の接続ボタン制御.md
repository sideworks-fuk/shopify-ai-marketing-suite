# 検討: 直接アクセス時の「接続を開始」ボタン制御

## 作成日: 2025-12-31
## 状態: 検討中

## 問題提起

フロントエンドで埋め込みではなく直接ルート（`/` または `/install`）にアクセスしたとき、「接続を開始」ボタンを使用できないように制御すべきか検討が必要です。

## 対象ルート

### 1. `/` (ルートページ)
- **ファイル**: `frontend/src/app/page.tsx`
- **役割**: リダイレクト専用ページ
- **動作**:
  - 認証済み → `/customers/dormant`（メインダッシュボード）へリダイレクト
  - 未認証（開発環境） → `/auth/select`（認証方法選択画面）へリダイレクト
  - 未認証（本番環境） → `/install`（インストールページ）へリダイレクト
- **直接アクセス時の制御**: リダイレクト専用のため、直接アクセス時の制御は不要（常に適切なページへリダイレクト）

### 2. `/install` (インストールページ)
- **ファイル**: `frontend/src/app/install/page.tsx`
- **役割**: Shopifyアプリ接続・認証ページ
- **機能**: 「接続を開始」ボタンでOAuth認証を開始
- **直接アクセス時の制御**: **検討が必要**（本ドキュメントの主な対象）

## 現状の実装

### `/install` ページのボタン制御

```tsx
<Button
  variant="primary"
  size="large"
  fullWidth
  onClick={handleInstall}
  loading={loading}
  disabled={!shopDomain.trim() || autoRedirecting}
>
  {loading ? '接続中...' : '接続を開始'}
</Button>
```

**現在のdisabled条件:**
- `!shopDomain.trim()` - ストアドメインが入力されていない
- `autoRedirecting` - 自動リダイレクト処理中

**埋め込みモード判定:**
- `useIsEmbedded()`フックで埋め込みモードを判定しているが、ボタンの無効化には使用していない

## 検討事項

### 1. Shopifyの推奨事項

#### 公式ドキュメントの見解
- **埋め込みアプリとしてShopify管理画面からアクセスすることを推奨**
- ただし、直接アクセスを完全に禁止するかどうかは明示されていない
- OAuth認証が必要なため、セキュリティ的には直接アクセスでも問題ない

#### App Store審査基準
- **必須要件**: インストール直後にOAuth認証を実行
- **禁止事項**: 認証前UI表示、ポップアップ認証、手動ドメイン入力要求
- **注意**: 直接アクセスを許可する場合、適切なガイダンスが必要

### 2. セキュリティ上の懸念

#### 直接アクセスを許可する場合
- ✅ OAuth認証が必要なため、セキュリティ的には問題ない
- ✅ ストアドメインの手動入力は、OAuth認証フローの一部として必要
- ⚠️ ただし、適切なガイダンスがないとUXが悪化

#### 直接アクセスを禁止する場合
- ✅ Shopifyの推奨事項に完全に準拠
- ✅ より安全なUXを提供
- ❌ 開発・テスト時の利便性が低下
- ❌ カスタムアプリの場合、直接アクセスが必要なケースがある

### 3. UXの観点

#### 直接アクセスを許可する場合
- **推奨**: 適切なガイダンスを表示
  - 「推奨されるアクセス方法」カード（現在実装済み）
  - 埋め込みモードでない場合の警告メッセージ
  - Shopify管理画面からのアクセス方法を案内

#### 直接アクセスを禁止する場合
- **推奨**: 明確なエラーメッセージとリダイレクト案内
  - 「このアプリはShopify管理画面からアクセスしてください」メッセージ
  - Shopify管理画面へのリダイレクトリンク

### 4. 実装の複雑さ

#### オプション1: ボタンを無効化（推奨）
```tsx
disabled={!shopDomain.trim() || autoRedirecting || !isEmbedded}
```

**メリット:**
- 実装が簡単
- Shopifyの推奨事項に準拠
- セキュリティが向上

**デメリット:**
- カスタムアプリの場合、直接アクセスが必要なケースがある
- 開発・テスト時の利便性が低下

#### オプション2: 警告メッセージを表示（推奨）
```tsx
{!isEmbedded && (
  <Banner tone="warning">
    <Text>
      このアプリはShopify管理画面からアクセスすることを推奨します。
      直接アクセスした場合、一部の機能が制限される可能性があります。
    </Text>
  </Banner>
)}
```

**メリット:**
- 柔軟性が高い
- 開発・テスト時に便利
- カスタムアプリにも対応可能

**デメリット:**
- ユーザーが警告を無視する可能性
- 実装がやや複雑

#### オプション3: 環境別制御
```tsx
const isProduction = process.env.NEXT_PUBLIC_ENVIRONMENT === 'production';
const shouldDisableDirectAccess = isProduction && !isEmbedded;

disabled={!shopDomain.trim() || autoRedirecting || shouldDisableDirectAccess}
```

**メリット:**
- 本番環境では厳格に制御
- 開発環境では柔軟に対応
- ベストプラクティスに準拠

**デメリット:**
- 環境変数の管理が必要
- 実装がやや複雑

## 推奨案

### 推奨: オプション2（警告メッセージ） + オプション3（環境別制御）の組み合わせ

#### 対象ルート

- **`/` (ルートページ)**: リダイレクト専用のため、追加の制御は不要
- **`/install` (インストールページ)**: 本検討の対象（「接続を開始」ボタンがある）

#### 実装方針

1. **`/` ルート**: 既存のリダイレクト機能を維持（変更不要）
2. **`/install` ルート**: 本番環境で直接アクセス時に警告メッセージを表示し、ボタンは有効のまま
3. **開発環境**: 直接アクセスを許可（開発・テストの利便性のため）
4. **カスタムアプリ**: 直接アクセスを許可（カスタムアプリの特性上、直接アクセスが必要なケースがある）

#### 実装例

```tsx
const isProduction = process.env.NEXT_PUBLIC_ENVIRONMENT === 'production';
const isDirectAccess = !isEmbedded;
const showDirectAccessWarning = isProduction && isDirectAccess;

// ボタンのdisabled条件（本番環境では直接アクセスを無効化しない）
disabled={!shopDomain.trim() || autoRedirecting}

// 警告メッセージ
{showDirectAccessWarning && (
  <Banner tone="warning" onDismiss={() => {}}>
    <Text>
      <strong>推奨されるアクセス方法</strong><br />
      このアプリはShopify管理画面からアクセスすることを推奨します。
      直接アクセスした場合、一部の機能が制限される可能性があります。
    </Text>
  </Banner>
)}
```

## 代替案

### 代替案1: 完全にボタンを無効化

```tsx
disabled={!shopDomain.trim() || autoRedirecting || !isEmbedded}
```

**適用条件:**
- 公開アプリのみ
- カスタムアプリでは適用しない

### 代替案2: リダイレクト案内

```tsx
if (!isEmbedded && isProduction) {
  // Shopify管理画面へのリダイレクト案内を表示
  return <DirectAccessWarning />;
}
```

## 判断基準

### ボタンを無効化すべき場合
- ✅ 公開アプリとして申請する場合
- ✅ Shopifyの推奨事項に完全に準拠したい場合
- ✅ セキュリティを最優先する場合

### ボタンを有効のままにする場合
- ✅ カスタムアプリの場合
- ✅ 開発・テスト時の利便性を重視する場合
- ✅ 警告メッセージで十分と判断する場合

## 次のステップ

1. [ ] プロジェクトの方針を決定
   - 公開アプリのみ対象か、カスタムアプリも含めるか
   - 本番環境のみ制御するか、全環境で制御するか

2. [ ] 実装方法を決定
   - オプション1（ボタン無効化）
   - オプション2（警告メッセージ）
   - オプション3（環境別制御）
   - オプション4（固定ページ表示）← **新規追加**
   - 組み合わせ

3. [ ] 実装
   - `frontend/src/app/install/page.tsx` を更新（`/` ルートは変更不要）
   - 警告メッセージの追加（必要に応じて）

4. [ ] テスト
   - **`/` ルート**: リダイレクト動作の確認（既存機能の確認）
   - **`/install` ルート**: 
     - 埋め込みモードでの動作確認
     - 直接アクセス時の動作確認
     - 警告メッセージの表示確認

## 追加検討: 固定ページ表示（より厳格な制御）

### オプション4: 埋め込みアプリでない場合は固定ページを表示

**概要**: 埋め込みアプリでない場合、`/install` ページへリダイレクトせず、専用の固定ページ（例：`/install-blocked`）を表示する。

#### 実装方法

**方法1: Middlewareでリダイレクト**

```typescript
// frontend/src/middleware.ts
export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;
  
  // /install へのアクセスをチェック
  if (pathname === '/install' || pathname.startsWith('/install/')) {
    // アプリタイプの確認（環境変数から取得）
    const appType = process.env.NEXT_PUBLIC_SHOPIFY_APP_TYPE || 'Public';
    
    // カスタムアプリの場合は制御をスキップ
    if (appType === 'Custom') {
      return NextResponse.next();
    }
    
    // 埋め込みモード判定（URLパラメータで判定）
    // 注意: Middlewareはサーバーサイドで実行されるため、クライアントサイドのuseIsEmbedded()は使用できない
    const shop = request.nextUrl.searchParams.get('shop');
    const host = request.nextUrl.searchParams.get('host');
    const embedded = request.nextUrl.searchParams.get('embedded');
    
    // 正規のアクセス経路かどうか
    const isLegitimateAccess = !!shop || !!host || !!embedded;
    
    // 開発環境の判定
    const isDevelopment = process.env.NEXT_PUBLIC_ENVIRONMENT === 'development';
    
    // 非正規アクセスで本番環境の場合、固定ページへリダイレクト
    if (!isLegitimateAccess && !isDevelopment) {
      const url = request.nextUrl.clone();
      url.pathname = '/install-blocked';
      return NextResponse.redirect(url);
    }
  }
  
  return NextResponse.next();
}
```

**方法2: /install ページ内で早期リダイレクト**

```typescript
// frontend/src/app/install/page.tsx
useEffect(() => {
  // 埋め込みモード判定
  const isEmbedded = useIsEmbedded();
  const hasShopParam = searchParams.get('shop') !== null;
  const isDevelopment = getCurrentEnvironment() === 'development';
  
  const isLegitimateAccess = isEmbedded || hasShopParam || isDevelopment;
  
  // 非正規アクセスの場合、固定ページへリダイレクト
  if (!isLegitimateAccess) {
    router.replace('/install-blocked');
  }
}, [isEmbedded, searchParams]);
```

#### 固定ページの作成

**新規ファイル**: `frontend/src/app/install-blocked/page.tsx`

**パターン1: エラーページ形式（シンプル）**

```tsx
'use client';

import { Page, Card, Banner, Text, Box, Button, BlockStack, List } from '@shopify/polaris';
import { SHOPIFY_APP_STORE_URL } from '@/constants/shopify';

export default function InstallBlockedPage() {
  return (
    <Page>
      <Card>
        <BlockStack gap="400">
          <Banner
            title="Shopify App Storeからインストールしてください"
            tone="critical"
          >
            <Text as="p">
              このアプリは直接アクセスからのインストールには対応していません。
              Shopify App Storeからインストールしてください。
            </Text>
            <Box paddingBlockStart="400">
              <Button
                url={SHOPIFY_APP_STORE_URL}
                external
                variant="primary"
              >
                App Storeでインストール
              </Button>
            </Box>
          </Banner>
          
          <Text as="h2" variant="headingMd">
            推奨されるインストール方法
          </Text>
          <List type="number">
            <List.Item>
              Shopify App Storeで「EC Ranger」を検索
            </List.Item>
            <List.Item>
              「インストール」ボタンをクリック
            </List.Item>
            <List.Item>
              Shopify管理画面からアプリにアクセス
            </List.Item>
          </List>
        </BlockStack>
      </Card>
    </Page>
  );
}
```

**パターン2: アプリ紹介トップページ形式（推奨）**

```tsx
'use client';

import { Page, Card, Text, Box, Button, BlockStack, InlineStack, Banner } from '@shopify/polaris';
import { SHOPIFY_APP_STORE_URL } from '@/constants/shopify';

export default function InstallBlockedPage() {
  return (
    <Page>
      <BlockStack gap="600">
        {/* ヒーローセクション */}
        <Card>
          <BlockStack gap="400">
            <Text as="h1" variant="heading2xl">
              EC Ranger
            </Text>
            <Text as="p" variant="bodyLg" tone="subdued">
              AIを活用したShopifyストアの売上分析・顧客分析ツール
            </Text>
            <Box paddingBlockStart="400">
              <Button
                url={SHOPIFY_APP_STORE_URL}
                external
                variant="primary"
                size="large"
              >
                Shopify App Storeでインストール
              </Button>
            </Box>
          </BlockStack>
        </Card>

        {/* 注意メッセージ */}
        <Banner
          title="このアプリはShopify App Storeからインストールしてください"
          tone="info"
        >
          <Text as="p">
            このアプリは直接アクセスからのインストールには対応していません。
            Shopify App Storeからインストールすることで、安全にアプリを利用できます。
          </Text>
        </Banner>

        {/* アプリの特徴 */}
        <Card>
          <BlockStack gap="400">
            <Text as="h2" variant="headingLg">
              主な機能
            </Text>
            <BlockStack gap="300">
              <Text as="h3" variant="headingMd">
                📊 売上データのAI分析
              </Text>
              <Text as="p" tone="subdued">
                過去の売上データをAIで分析し、トレンドやパターンを可視化します。
              </Text>
              
              <Text as="h3" variant="headingMd">
                👥 顧客行動の詳細な分析
              </Text>
              <Text as="p" tone="subdued">
                顧客の購買行動を分析し、休眠顧客の特定やリピート購入の促進をサポートします。
              </Text>
              
              <Text as="h3" variant="headingMd">
                📈 商品パフォーマンスの可視化
              </Text>
              <Text as="p" tone="subdued">
                商品ごとの売上パフォーマンスを可視化し、人気商品や改善が必要な商品を特定します。
              </Text>
              
              <Text as="h3" variant="headingMd">
                🎯 マーケティング施策の最適化提案
              </Text>
              <Text as="p" tone="subdued">
                AIが分析結果に基づいて、効果的なマーケティング施策を提案します。
              </Text>
            </BlockStack>
          </BlockStack>
        </Card>

        {/* インストール方法 */}
        <Card>
          <BlockStack gap="400">
            <Text as="h2" variant="headingLg">
              インストール方法
            </Text>
            <BlockStack gap="300">
              <Text as="p">
                <strong>ステップ1:</strong> Shopify App Storeで「EC Ranger」を検索
              </Text>
              <Text as="p">
                <strong>ステップ2:</strong> 「インストール」ボタンをクリック
              </Text>
              <Text as="p">
                <strong>ステップ3:</strong> Shopify管理画面からアプリにアクセス
              </Text>
            </BlockStack>
            <Box paddingBlockStart="400">
              <Button
                url={SHOPIFY_APP_STORE_URL}
                external
                variant="primary"
                size="large"
                fullWidth
              >
                Shopify App Storeでインストール
              </Button>
            </Box>
          </BlockStack>
        </Card>
      </BlockStack>
    </Page>
  );
}
```

**パターン比較**

| 項目 | エラーページ形式 | アプリ紹介トップページ形式 |
|------|----------------|-------------------------|
| UX | エラー感が強い | ポジティブな印象 |
| マーケティング効果 | 低 | 高（アプリの魅力を伝えられる） |
| 実装の複雑さ | 低 | 中 |
| 推奨ケース | シンプルな制御 | アプリの紹介も兼ねたい場合 |

#### メリット

- ✅ **より厳格な制御**: `/install` ページ自体に到達させない
- ✅ **明確なメッセージ**: ユーザーに直接アクセスが許可されていないことを明確に伝える
- ✅ **セキュリティ**: インストールページのコードが実行されない
- ✅ **UX**: 専用ページで統一されたメッセージを表示

#### デメリット

- ❌ **実装の複雑さ**: Middlewareまたは早期リダイレクトの実装が必要
- ❌ **開発・テスト時の不便**: 開発環境でも制御が必要な場合、テストが困難
- ❌ **カスタムアプリへの対応**: カスタムアプリの場合、直接アクセスが必要なケースがある
- ❌ **Middlewareの制限**: サーバーサイドで実行されるため、クライアントサイドの `useIsEmbedded()` は使用できない

#### 推奨される使用ケース

- **公開アプリのみ**: カスタムアプリでは使用しない
- **本番環境のみ**: 開発環境では許可
- **厳格な制御が必要な場合**: App Store経由のインストールを強制したい場合

#### 比較: 警告バナー vs 固定ページ

| 項目 | 警告バナー（現在の仕様） | 固定ページ（オプション4） |
|------|------------------------|-------------------------|
| 実装の複雑さ | 低 | 中 |
| 制御の厳格さ | 中 | 高 |
| UX | 警告表示 | 専用ページ |
| 開発・テスト | 容易 | やや困難 |
| カスタムアプリ対応 | 容易 | 環境変数で制御可能 |
| 推奨ケース | 一般的な公開アプリ | 厳格な制御が必要な場合 |
| セキュリティ | 中 | 高（ページに到達しない） |

#### 実装時の注意事項

1. **Middlewareでの判定制限**: 
   - Middlewareはサーバーサイドで実行されるため、クライアントサイドの `useIsEmbedded()` は使用できない
   - URLパラメータ（`shop`, `host`, `embedded`）で判定する必要がある
   - 埋め込みモードの判定が完全ではない可能性がある

2. **開発環境の考慮**: 
   - 開発環境では常に許可するか、環境変数で制御可能にする

3. **カスタムアプリの考慮**: 
   - `SHOPIFY_APP_TYPE` が `'Custom'` の場合は、この制御をスキップする

4. **`/` ルートへの影響**: 
   - `/` ルートから `/install` へのリダイレクト時に、`shop` パラメータがない場合は `/install-blocked` にリダイレクトされる可能性がある
   - `/` ルートのリダイレクトロジックも調整が必要

5. **通常のインストールフローへの影響（重要）**: 
   - 固定ページへのリダイレクトが、正規のインストールフローを妨げないか検証が必要
   - 特に以下のケースで問題が発生する可能性がある：
     - 埋め込みモードでのアクセス（Middlewareでは `isEmbedded` を判定できない）
     - OAuthコールバック処理（`code`, `state` パラメータ）
     - OAuth成功後のリダイレクト（`auth_success=true` パラメータ）

#### 推奨実装方針

**現時点では、オプション2（警告バナー）+ オプション3（環境別制御）の組み合わせを推奨**

理由：
- 実装が簡単
- 開発・テスト時の利便性が高い
- カスタムアプリへの対応が容易
- 十分なセキュリティを確保できる（OAuth認証は必須のため）

**オプション4（固定ページ）は、以下の場合に検討**：
- より厳格な制御が必要な場合
- App Store経由のインストールを強制したい場合
- セキュリティを最優先する場合

---

## ⚠️ 重要: 通常のインストールフローへの影響検証

### 問題の可能性

固定ページ（`/install-blocked`）へのリダイレクトが、**正規のインストールフローを妨げる可能性**があります。

#### 影響を受ける可能性があるケース

| # | ケース | 判定方法 | 問題の可能性 | 理由 |
|---|--------|---------|-------------|------|
| 1 | **App Store経由のインストール** | `shop` パラメータあり | ✅ **問題なし** | `isLegitimateAccess = true` で判定可能 |
| 2 | **埋め込みモードでのアクセス** | `isEmbedded = true` | ⚠️ **問題あり** | Middlewareでは `useIsEmbedded()` が使用できない |
| 3 | **OAuthコールバック処理** | `code`, `state` パラメータ | ⚠️ **問題あり** | Middlewareでは判定が不完全 |
| 4 | **OAuth成功後のリダイレクト** | `auth_success=true` パラメータ | ⚠️ **問題あり** | Middlewareでは判定が不完全 |
| 5 | **開発環境でのアクセス** | `NEXT_PUBLIC_ENVIRONMENT=development` | ✅ **問題なし** | `isDevelopment = true` で判定可能 |

### 詳細な問題分析

#### 問題1: 埋め込みモードの判定

**現状**: Middlewareはサーバーサイドで実行されるため、クライアントサイドの `useIsEmbedded()` は使用できない。

**影響**: 埋め込みモードでアクセスした場合でも、URLパラメータ（`shop`, `host`, `embedded`）がないと、誤って `/install-blocked` にリダイレクトされる可能性がある。

**解決策**:
```typescript
// Middlewareでの判定を緩和
const shop = request.nextUrl.searchParams.get('shop');
const host = request.nextUrl.searchParams.get('host');
const embedded = request.nextUrl.searchParams.get('embedded');
const code = request.nextUrl.searchParams.get('code'); // OAuthコールバック
const state = request.nextUrl.searchParams.get('state'); // OAuthコールバック
const authSuccess = request.nextUrl.searchParams.get('auth_success'); // OAuth成功

// より緩和された判定（OAuth関連パラメータも許可）
const isLegitimateAccess = 
  !!shop || 
  !!host || 
  !!embedded || 
  !!code || 
  !!state || 
  authSuccess === 'true';
```

#### 問題2: OAuthコールバック処理

**現状**: `/install` ページは、OAuthコールバック処理（`code`, `state` パラメータ）を受け取る必要がある。

**影響**: OAuthコールバック時に `/install-blocked` にリダイレクトされると、認証フローが中断される。

**解決策**: OAuthコールバックパラメータ（`code`, `state`）がある場合は、常に `/install` ページを許可する。

#### 問題3: OAuth成功後のリダイレクト

**現状**: `/install` ページは、OAuth成功後のリダイレクト（`auth_success=true` パラメータ）を受け取る必要がある。

**影響**: OAuth成功後に `/install-blocked` にリダイレクトされると、初期設定画面への遷移が失敗する。

**解決策**: `auth_success=true` パラメータがある場合は、常に `/install` ページを許可する。

### 修正版Middleware実装

```typescript
// frontend/src/middleware.ts
export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;
  
  // /install へのアクセスをチェック
  if (pathname === '/install' || pathname.startsWith('/install/')) {
    // アプリタイプの確認（環境変数から取得）
    const appType = process.env.NEXT_PUBLIC_SHOPIFY_APP_TYPE || 'Public';
    
    // カスタムアプリの場合は制御をスキップ
    if (appType === 'Custom') {
      return NextResponse.next();
    }
    
    // 開発環境の判定
    const isDevelopment = process.env.NEXT_PUBLIC_ENVIRONMENT === 'development';
    
    // 開発環境の場合は常に許可
    if (isDevelopment) {
      return NextResponse.next();
    }
    
    // 埋め込みモード判定（URLパラメータで判定）
    const shop = request.nextUrl.searchParams.get('shop');
    const host = request.nextUrl.searchParams.get('host');
    const embedded = request.nextUrl.searchParams.get('embedded');
    
    // OAuthコールバック処理の判定
    const code = request.nextUrl.searchParams.get('code');
    const state = request.nextUrl.searchParams.get('state');
    const authSuccess = request.nextUrl.searchParams.get('auth_success');
    const storeId = request.nextUrl.searchParams.get('storeId');
    
    // 正規のアクセス経路かどうか（より緩和された判定）
    const isLegitimateAccess = 
      !!shop ||           // App Store経由
      !!host ||           // Shopify管理画面経由
      !!embedded ||       // 埋め込みモード
      !!code ||           // OAuthコールバック
      !!state ||          // OAuthコールバック
      authSuccess === 'true' ||  // OAuth成功
      !!storeId;          // ストアID（OAuth成功後）
    
    // 非正規アクセスの場合、固定ページへリダイレクト
    if (!isLegitimateAccess) {
      const url = request.nextUrl.clone();
      url.pathname = '/install-blocked';
      return NextResponse.redirect(url);
    }
  }
  
  return NextResponse.next();
}
```

### 検証テストケース

| # | テストケース | 期待結果 | 検証方法 |
|---|------------|---------|---------|
| 1 | App Store経由（`shop`パラメータあり） | ✅ `/install` ページにアクセス可能 | `https://app.com/install?shop=example.myshopify.com` |
| 2 | 埋め込みモード（`host`パラメータあり） | ✅ `/install` ページにアクセス可能 | `https://app.com/install?host=xxx` |
| 3 | OAuthコールバック（`code`パラメータあり） | ✅ `/install` ページにアクセス可能 | `https://app.com/install?code=xxx&state=xxx` |
| 4 | OAuth成功後（`auth_success=true`） | ✅ `/install` ページにアクセス可能 | `https://app.com/install?auth_success=true&storeId=xxx` |
| 5 | 直接アクセス（パラメータなし） | ❌ `/install-blocked` にリダイレクト | `https://app.com/install` |
| 6 | 開発環境での直接アクセス | ✅ `/install` ページにアクセス可能 | `NEXT_PUBLIC_ENVIRONMENT=development` |

### 推奨実装方針（再評価）

**オプション4（固定ページ）の実装は、以下の条件を満たす場合のみ推奨**：

1. ✅ **OAuth関連パラメータの判定を追加**: `code`, `state`, `auth_success`, `storeId` を許可
2. ✅ **開発環境では常に許可**: テストの利便性を確保
3. ✅ **十分なテストを実施**: すべての正規フローで動作確認
4. ✅ **ロールバック計画を準備**: 問題発生時の即座の対応

**より安全な実装**: オプション2（警告バナー）+ オプション3（環境別制御）の組み合わせを推奨

理由：
- 正規のインストールフローを妨げるリスクが低い
- 実装が簡単で、テストが容易
- 問題発生時の影響が小さい

---

## 補足: ルート別の対応方針

| ルート | 役割 | 直接アクセス時の制御 | 理由 |
|--------|------|---------------------|------|
| `/` | リダイレクト専用 | **不要** | 常に適切なページへリダイレクトするため、追加の制御は不要 |
| `/install` | インストール・認証ページ | **検討が必要** | 「接続を開始」ボタンがあるため、直接アクセス時の制御を検討 |

### 実装対象

- **`/` ルート**: 既存のリダイレクト機能を維持（変更不要）
- **`/install` ルート**: 本検討の対象（警告メッセージの追加など）

## 参考資料

- [Shopify App Store 申請チェックリスト](./申請チェックリスト.md)
- [Shopify アプリ認証・認可設計](../../../05-development/09-認証・セキュリティ/Shopify-アプリ認証・認可設計.md)
- [Shopify App Bridge 実装メモ](../../../frontend/docs/shopify-app-bridge-implementation-notes.md)

---
**更新日**: 2025-12-31
**担当**: 要決定
