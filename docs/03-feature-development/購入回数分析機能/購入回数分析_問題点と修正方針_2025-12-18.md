# 購入回数分析ロジック 問題点と修正方針

**作成日**: 2025年12月18日  
**作成者**: 福田＋AI Assistant  
**ステータス**: 修正実施前

---

## 1. 現在の問題点

### 1.1 データ表示の不具合

#### 問題1: セグメント別データが同一
- **症状**: 「新規顧客」「既存顧客」「全顧客」を選択しても、すべて同じデータが表示される
- **原因**: セグメント判定ロジックが分析期間と正しく連動していない
- **影響**: ユーザーが正しい分析ができない

#### 問題2: 購入回数0回の非表示
- **症状**: 既存顧客で分析期間中に購入がない（0回）顧客が表示されない
- **原因**: データ取得時に購入実績がある顧客のみを抽出している
- **影響**: 休眠顧客の把握ができない

### 1.2 現在の実装状況

#### バックエンド（PurchaseCountDataService.cs）
```csharp
// 現在のセグメント判定（問題あり）
case "new":
    // 過去365日間の初回購入者（分析期間を無視）
    customerIds = await _context.Orders
        .Where(o => o.StoreId == storeId)
        .GroupBy(o => o.CustomerId)
        .Where(g => g.Min(o => o.CreatedAt) >= DateTime.UtcNow.AddDays(-365))
        .Select(g => g.Key)
        .ToListAsync();
```

**問題点**:
- 分析期間（3ヶ月、6ヶ月等）を無視して常に365日で判定
- 新規・既存の定義が不明確

---

## 2. 正しい仕様定義

### 2.1 顧客セグメントの定義

| セグメント | 定義 | 表示データ |
|------------|------|------------|
| **新規顧客** | 分析期間中に初めて購入した顧客<br>（全期間で初回購入） | 分析期間中の購入回数<br>（1回以上） |
| **既存顧客** | 分析期間開始前に購入履歴がある顧客 | 分析期間中の購入回数<br>（0回も含む） |
| **復帰顧客** | 休眠期間後に再購入した顧客<br>（180日以上購入なし→再購入） | 分析期間中の購入回数 |
| **全顧客** | すべての顧客 | 分析期間中の購入回数 |

### 2.2 期間との関係

```
例：分析期間「過去3ヶ月」を選択した場合

        ←── 過去全期間 ──→│←─ 3ヶ月 ─→│今日
                         ↑
                    分析期間開始日

新規顧客: 全期間で初購入が3ヶ月以内
既存顧客: 3ヶ月より前に購入履歴あり
```

---

## 3. 修正方針

### 3.1 バックエンドの修正

#### Step 1: セグメント判定に期間を反映
```csharp
// 修正後のセグメント判定
public async Task<List<int>> GetSegmentCustomerIdsAsync(
    int storeId, 
    string segment,
    DateTime startDate,  // 分析期間開始
    DateTime endDate)    // 分析期間終了
{
    switch (segment.ToLower())
    {
        case "new":
            // 全期間での初回購入が分析期間内
            var newCustomers = await _context.Orders
                .Where(o => o.StoreId == storeId)
                .GroupBy(o => o.CustomerId)
                .Where(g => g.Min(o => o.CreatedAt) >= startDate 
                         && g.Min(o => o.CreatedAt) <= endDate)
                .Select(g => g.Key)
                .ToListAsync();
            return newCustomers;

        case "existing":
            // 分析期間前に購入履歴あり
            var existingCustomers = await _context.Orders
                .Where(o => o.StoreId == storeId 
                         && o.CreatedAt < startDate)
                .Select(o => o.CustomerId)
                .Distinct()
                .ToListAsync();
            return existingCustomers;
    }
}
```

#### Step 2: 購入回数0回の顧客を含める
```csharp
// 既存顧客の購入回数取得（0回も含む）
public async Task<List<CustomerPurchaseCount>> GetExistingCustomerPurchaseCounts(
    int storeId,
    DateTime startDate,
    DateTime endDate)
{
    // 既存顧客リスト取得
    var existingCustomerIds = await GetSegmentCustomerIdsAsync(
        storeId, "existing", startDate, endDate);
    
    // 分析期間中の購入データ
    var purchases = await _context.Orders
        .Where(o => o.StoreId == storeId 
                 && o.CreatedAt >= startDate 
                 && o.CreatedAt <= endDate)
        .GroupBy(o => o.CustomerId)
        .Select(g => new { 
            CustomerId = g.Key, 
            Count = g.Count() 
        })
        .ToDictionaryAsync(x => x.CustomerId, x => x.Count);
    
    // 既存顧客全員の結果を作成（購入なしは0回）
    var result = existingCustomerIds.Select(customerId => new CustomerPurchaseCount
    {
        CustomerId = customerId,
        PurchaseCount = purchases.ContainsKey(customerId) 
            ? purchases[customerId] 
            : 0  // 購入なしは0回
    }).ToList();
    
    return result;
}
```

### 3.2 フロントエンドの修正

#### 購入回数0回の表示対応
```typescript
// PurchaseCountAnalysis.tsx
const renderPurchaseCountTable = () => {
    // 0回も含めて表示
    const displayData = purchaseData.filter(item => {
        if (selectedSegment === 'existing') {
            return true; // 既存顧客は0回も表示
        }
        return item.count > 0; // 他は1回以上のみ
    });
    
    return (
        <Table>
            {displayData.map(item => (
                <TableRow key={item.customerId}>
                    <TableCell>
                        {item.count === 0 ? (
                            <span className="text-gray-400">購入なし</span>
                        ) : (
                            `${item.count}回`
                        )}
                    </TableCell>
                </TableRow>
            ))}
        </Table>
    );
};
```

---

## 4. テストケース

### 4.1 セグメント別表示テスト

| テストケース | 期間 | セグメント | 期待結果 |
|-------------|------|------------|----------|
| TC1 | 過去3ヶ月 | 新規 | 3ヶ月以内の初回購入者のみ |
| TC2 | 過去3ヶ月 | 既存 | 3ヶ月前までの購入者（0回含む） |
| TC3 | 過去3ヶ月 | 全顧客 | すべての顧客データ |
| TC4 | 過去12ヶ月 | 新規 | 12ヶ月以内の初回購入者のみ |

### 4.2 購入回数0回の表示テスト

| テストケース | 条件 | 期待結果 |
|-------------|------|----------|
| TC5 | 既存顧客で期間中購入なし | 「0回」または「購入なし」と表示 |
| TC6 | 新規顧客 | 0回は表示されない（定義上1回以上） |

---

## 5. 実装スケジュール

### Phase 1: バックエンドロジック修正（2時間）
1. PurchaseCountDataService.csの修正
2. GetSegmentCustomerIdsAsyncメソッドの期間対応
3. 0回購入の顧客データ取得対応

### Phase 2: フロントエンド対応（1時間）
1. PurchaseCountAnalysis.tsxの修正
2. 0回表示のUI調整
3. セグメント選択時の表示更新

### Phase 3: テスト（1時間）
1. 各セグメントのデータ確認
2. 期間変更時の動作確認
3. 0回表示の確認

---

## 6. 影響範囲

### 影響を受けるファイル
- **バックエンド**:
  - `backend/ShopifyAnalyticsApi/Services/PurchaseCount/PurchaseCountDataService.cs`
  - `backend/ShopifyAnalyticsApi/Services/PurchaseCount/PurchaseCountAnalysisService.cs`
  - `backend/ShopifyAnalyticsApi/Controllers/PurchaseController.cs`

- **フロントエンド**:
  - `frontend/src/components/dashboards/PurchaseCountAnalysis.tsx`
  - `frontend/src/components/purchase/PurchaseCountConditionPanel.tsx`

### APIの変更
- エンドポイントの変更なし
- レスポンス形式の変更なし
- ロジックのみ修正

---

## 7. リスクと対策

| リスク | 影響度 | 対策 |
|--------|--------|------|
| 既存データとの不整合 | 中 | 段階的なリリースとモニタリング |
| パフォーマンス低下 | 低 | インデックス最適化、クエリ効率化 |
| UIの混乱 | 低 | 0回表示を明確にする |

---

## 8. 確認事項

### ビジネス要件の確認
- [ ] 新規顧客の定義：「全期間で初回購入」で正しいか？
- [ ] 既存顧客で0回表示：マーケティング施策に有用か？
- [ ] 復帰顧客の休眠期間：180日で適切か？

### 技術的確認
- [ ] データベースのインデックス状況
- [ ] 大量データでのパフォーマンス
- [ ] キャッシュ戦略

---

## 次のステップ

1. このドキュメントのレビュー・承認
2. バックエンドの実装開始
3. フロントエンドの対応
4. 統合テスト
5. 本番リリース

---

**補足**: 
- 既に一部実装済みの内容（2025-12-03の改修）を含む
- トライアル実施前に必ず修正が必要
