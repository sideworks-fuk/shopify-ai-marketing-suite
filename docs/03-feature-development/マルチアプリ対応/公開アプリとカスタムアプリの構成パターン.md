# 公開アプリとカスタムアプリの構成パターン

## 結論：必ずしも複数作る必要はない

構成方法は**3パターン**あります。現在の実装状況を考慮した推奨を記載します。

---

## 現在の環境情報

| 項目 | 値 |
|------|-----|
| バックエンドURL | `https://ec-ranger-backend-prod-ghf3bbarghcwh4gn.japanwest-01.azurewebsites.net` |
| フロントエンドURL | `https://white-island-08e0a6300.2.azurestaticapps.net` |
| リージョン | Japan West |
| データベース | `ec-ranger-db-prod` (ec-ranger-sql-prod.database.windows.net) |

### 既存の実装状況

- ✅ `Store`テーブルに`ApiKey`と`ApiSecret`フィールドが既に存在（後方互換性のため残す）
  - `ApiKey` (nvarchar(255), NULL許可) - **非推奨**
  - `ApiSecret` (nvarchar(255), NULL許可) - **非推奨**
- ✅ `ShopifyApps`テーブルを新規作成（EF Core Migrationで実装予定）
- ✅ `Store`テーブルに`ShopifyAppId`フィールドを追加（外部キー）
- ⚠️ 現在は環境変数から1つのAPI Key/Secretのみを取得
- ⚠️ `ShopifyApps`テーブルから取得する処理は未実装（今後の実装が必要）

**注意**: 新規実装では`ShopifyApps`テーブルを優先的に使用します。詳細は `ShopifyAppsテーブル設計書.md` を参照してください。

---

## パターン1: 完全分離（最も安全）

```
┌─────────────────────────────────────────────────────────┐
│ 公開アプリ用                                              │
│  ├─ Shopifyアプリ: EC Ranger（公開）                      │
│  ├─ フロントエンド: ec-ranger-public.azurestaticapps.net │
│  ├─ バックエンド: ec-ranger-backend-public.azurewebsites.net │
│  └─ データベース: ec-ranger-db-public                    │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│ カスタムアプリ用                                          │
│  ├─ Shopifyアプリ: EC Ranger-demo（カスタム）             │
│  ├─ フロントエンド: ec-ranger-custom.azurestaticapps.net │
│  ├─ バックエンド: ec-ranger-backend-custom.azurewebsites.net │
│  └─ データベース: ec-ranger-db-custom                    │
└─────────────────────────────────────────────────────────┘
```

| メリット | デメリット |
|----------|------------|
| ✅ 完全に独立 | ❌ コスト2倍（App Service、Static Web Apps、SQL Database） |
| ✅ 障害の影響が分離 | ❌ 管理が煩雑（デプロイ、環境変数設定が2倍） |
| ✅ セキュリティリスク低 | ❌ コードの同期が必要 |
| ✅ スケール要件が異なる場合に対応可能 | ❌ メンテナンス負荷が増える |

---

## パターン2: バックエンド共有（推奨）

```
┌─────────────────────────────────────────────────────────┐
│ Shopifyアプリ                                            │
│  ├─ EC Ranger（公開）→ API Key: AAA                      │
│  └─ EC Ranger-demo（カスタム）→ API Key: BBB             │
└─────────────────────────────────────────────────────────┘
            ↓                    ↓
┌───────────────────┐   ┌───────────────────┐
│ フロントエンド（公開）│   │ フロントエンド（カスタム）│
│ App URL: /install  │   │ App URL: /install  │
│ 環境変数:          │   │ 環境変数:          │
│  NEXT_PUBLIC_      │   │  NEXT_PUBLIC_      │
│  SHOPIFY_API_KEY=  │   │  SHOPIFY_API_KEY=  │
│  AAA               │   │  BBB               │
└───────────────────┘   └───────────────────┘
            ↓                    ↓
┌─────────────────────────────────────────────────────────┐
│ バックエンド（共有）                                      │
│ - フロントエンドからapiKeyを受け取る                     │
│ - ShopifyAppsテーブルから取得（優先）                    │
│ - データベースに保存されていない場合は                    │
│   環境変数のデフォルト値を使用（フォールバック）           │
│ - 1つのデータベースで全ストアを管理                      │
└─────────────────────────────────────────────────────────┘
```

### 実装方法

#### バックエンド: データベースベースのCredentials管理

```csharp
// ShopifyAuthController.cs
private async Task<(string ApiKey, string ApiSecret)> GetShopifyCredentialsAsync(string shopDomain)
{
    try
    {
        // 1. データベースからストア情報を取得（ShopifyAppを含む）
        var store = await _context.Stores
            .Include(s => s.ShopifyApp)
            .FirstOrDefaultAsync(s => s.Domain == shopDomain);
        
        // 2. ShopifyAppテーブルから取得（優先）
        if (store?.ShopifyApp != null && store.ShopifyApp.IsActive)
        {
            _logger.LogInformation("ShopifyAppテーブルからCredentialsを取得. Shop: {Shop}, App: {AppName}", 
                shopDomain, store.ShopifyApp.Name);
            return (store.ShopifyApp.ApiKey, store.ShopifyApp.ApiSecret);
        }
        
        // 3. 後方互換性: Store.ApiKey/ApiSecretから取得
        if (store != null && 
            !string.IsNullOrEmpty(store.ApiKey) && 
            !string.IsNullOrEmpty(store.ApiSecret))
        {
            _logger.LogInformation("Using store-specific credentials for {Shop}", shopDomain);
            return (store.ApiKey, store.ApiSecret);
        }
        
        // 3. フォールバック: 環境変数から取得
        var defaultApiKey = GetShopifySetting("ApiKey");
        var defaultApiSecret = GetShopifySetting("ApiSecret");
        
        _logger.LogInformation("Using default credentials from configuration for {Shop}", shopDomain);
        return (defaultApiKey, defaultApiSecret);
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Failed to get Shopify credentials for {Shop}, falling back to default", shopDomain);
        // エラー時は環境変数のデフォルト値を使用
        return (GetShopifySetting("ApiKey"), GetShopifySetting("ApiSecret"));
    }
}
```

**注意**: 現在の実装では、`ApiSecret`は平文で保存されます。将来的にセキュリティを強化する場合は、暗号化を追加することを推奨します（後述の「セキュリティ考慮事項」を参照）。

#### フロントエンド: 環境変数でAPI Keyを設定

```bash
# 公開アプリ用デプロイ
NEXT_PUBLIC_SHOPIFY_API_KEY=公開アプリのAPIキー

# カスタムアプリ用デプロイ
NEXT_PUBLIC_SHOPIFY_API_KEY=カスタムアプリのAPIキー
```

**注意**: フロントエンドのAPI Keyは主にShopify App Bridgeの初期化に使用されます。OAuth認証フロー自体はバックエンドで処理されるため、バックエンドが適切なAPI Key/Secretを選択します。

| メリット | デメリット |
|----------|------------|
| ✅ バックエンドコスト削減 | ⚠️ バックエンド実装が少し複雑（データベースから取得する処理が必要） |
| ✅ ビジネスロジック共有 | ⚠️ フロントエンドは別々にデプロイする必要がある |
| ✅ DBも共有可能 | |
| ✅ コスト効率が良い | |

---

## パターン3: 完全共有（非推奨）

```
┌─────────────────────────────────────────────────────────┐
│ 1つのフロントエンド + 1つのバックエンド                   │
│                                                         │
│ - URLパラメータでアプリを切り替え                        │
│   例: /install?app=public または /install?app=custom    │
│ - バックエンドで動的にAPI Key/Secretを選択               │
└─────────────────────────────────────────────────────────┘
```

| メリット | デメリット |
|----------|------------|
| ✅ 最もコスト効率が良い | ❌ 実装が複雑 |
| ✅ 管理が簡単 | ❌ **Shopify PartnersでApp URLが同じになり審査で問題の可能性** |
| | ❌ Shopifyの要件上、各アプリに異なるApp URLが必要 |

**⚠️ 重要**: Shopify Partnersでは、各アプリに異なるApp URLを設定する必要があります。パターン3では、公開アプリとカスタムアプリで同じApp URLを使用することになり、Shopifyの審査で問題になる可能性があります。

---

## 🎯 現状の推奨

**今の段階では「パターン2」が最適です：**

| 項目 | 設定 |
|------|------|
| **公開アプリ** | EC Ranger（一般公開用） |
| **カスタムアプリ（公開前レビュー用）** | EC Ranger-demo |
| **フロントエンド** | 1つ（環境変数でAPI Keyを切り替え可能） |
| **バックエンド** | 1つ（共有、データベースからCredentials取得） |
| **データベース** | 1つ（全ストアを管理） |

### 実装のポイント

1. **バックエンド**: ストアドメインに基づいてデータベースからAPI Key/Secretを取得
   - データベースに保存されていない場合は、環境変数のデフォルト値を使用
   - OAuth認証時に自動的に適切なCredentialsを選択

2. **フロントエンド**: 環境変数でAPI Keyを設定
   - 公開アプリ用とカスタムアプリ用で異なる環境変数を設定
   - または、同じフロントエンドを使用し、バックエンドが適切に処理

3. **Shopify Partners設定**:
   - 各アプリに異なるApp URLを設定
   - 各アプリに異なるAllowed redirection URLsを設定

---

## データベーススキーマの確認

### 既存の実装

**既存の実装**: `Store`テーブルには既に以下のフィールドが存在します：

| カラム名 | 型 | 説明 |
|----------|------|------|
| ApiKey | nvarchar(255) | ストア固有のShopify API Key（NULL許可） |
| ApiSecret | nvarchar(255) | ストア固有のShopify API Secret（NULL許可、現在は平文） |

これらのフィールドを活用することで、**追加のマイグレーションは不要**です。

### オプション: セキュリティ強化のための追加フィールド

セキュリティを強化する場合は、以下のフィールドを追加できます：

| カラム名 | 型 | 説明 |
|----------|------|------|
| ApiSecretEncrypted | nvarchar(500) | 暗号化されたAPI Secret（NULL許可） |
| AppType | nvarchar(20) | 'Public' または 'Custom'（NULL許可） |

**注意**: 
- `ApiSecretEncrypted`を追加する場合は、既存の`ApiSecret`フィールドとの使い分けを明確にする必要があります
- `AppType`フィールドは、`ApiKey`で識別可能なため必須ではありません

### マイグレーション例（オプション）

```sql
-- セキュリティ強化のために追加する場合のみ実行
ALTER TABLE Stores ADD ApiSecretEncrypted nvarchar(500) NULL;
ALTER TABLE Stores ADD AppType nvarchar(20) NULL DEFAULT 'Custom';

-- 既存のApiSecretフィールドを暗号化してApiSecretEncryptedに移行する場合は、
-- データ移行スクリプトが必要です。
```

---

## セキュリティ考慮事項

### 実装の優先順位

#### Phase 1: 基本実装（現在推奨）

- ✅ データベースに`ApiKey`と`ApiSecret`を保存（平文）
- ✅ 環境変数でデフォルト値を設定
- ⚠️ **注意**: 本番環境では、データベースへのアクセスを制限し、ログにAPI Secretが出力されないようにする

#### Phase 2: セキュリティ強化（推奨）

- 🔒 `ApiSecret`を暗号化して保存（ASP.NET Core Data Protection使用）
- 🔒 Azure Key Vaultの活用を検討
- 🔒 データベースアクセスの監査ログを有効化

#### Phase 3: 高度なセキュリティ（将来）

- 🔒 各ストアのAPI SecretをAzure Key Vaultに保存
- 🔒 動的なシークレットローテーション

### API Secretの暗号化（Phase 2）

データベースにAPI Secretを保存する場合は、将来的に暗号化することを推奨します。

#### 方法1: ASP.NET Core Data Protection（推奨）

```csharp
public class StoreService
{
    private readonly IDataProtector _protector;
    
    public StoreService(IDataProtectionProvider provider)
    {
        _protector = provider.CreateProtector("ShopifyApiSecrets");
    }
    
    public string EncryptSecret(string secret) => _protector.Protect(secret);
    public string DecryptSecret(string encrypted) => _protector.Unprotect(encrypted);
}
```

#### 方法2: Azure Key Vault

```csharp
// Azure Key Vaultから直接取得
var secret = await _keyVaultClient.GetSecretAsync(
    $"https://ec-ranger-vault.vault.azure.net/secrets/shopify-secret-{storeId}");
```

### 環境変数での管理

本番環境では、API SecretをAzure App Serviceの環境変数で管理し、`appsettings.json`には記載しないでください。

```bash
# Azure App Service 環境変数
Shopify__ApiKey=[YOUR_SHOPIFY_API_KEY]
Shopify__ApiSecret=[YOUR_SHOPIFY_API_SECRET]
```

---

## フロントエンドの複数デプロイ方法

### 方法A: 別々のStatic Web Appsリソースを作成（推奨）

```
┌─────────────────────────────────────────────────────────┐
│ ec-ranger-frontend-public                                │
│  └─ 環境変数: NEXT_PUBLIC_SHOPIFY_API_KEY=公開用APIキー  │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│ ec-ranger-frontend-custom                                │
│  └─ 環境変数: NEXT_PUBLIC_SHOPIFY_API_KEY=カスタム用APIキー │
└─────────────────────────────────────────────────────────┘
```

### 方法B: 同一リソースでブランチごとにデプロイ

```
┌─────────────────────────────────────────────────────────┐
│ ec-ranger-frontend                                       │
│  ├─ main ブランチ → production環境（公開アプリ用）       │
│  │   └─ 環境変数: NEXT_PUBLIC_SHOPIFY_API_KEY=公開用    │
│  └─ custom ブランチ → staging環境（カスタムアプリ用）    │
│      └─ 環境変数: NEXT_PUBLIC_SHOPIFY_API_KEY=カスタム用 │
└─────────────────────────────────────────────────────────┘
```

Azure Static Web Appsでは、各環境で異なる環境変数を設定可能です。

### 方法C: 同一リソースで環境変数で切り替え（簡易版）

現在の実装では、1つのStatic Web Appsリソースを使用し、環境変数でAPI Keyを切り替えることも可能です。

**制限**: 同時に両方のアプリをサポートできないため、公開前レビュー用と一般公開用で切り替える必要があります。

**推奨**: 方法A（別々のStatic Web Appsリソース）を推奨します。

---

## 具体的な実装方法

### バックエンドで複数アプリをサポート

#### 方法A: データベースベース（推奨）

```csharp
// appsettings.json（デフォルト値のみ）
{
  "Shopify": {
    "ApiKey": "デフォルトのAPIキー",
    "ApiSecret": "環境変数で設定"
  }
}

// データベースでストアごとに設定
UPDATE Stores 
SET ApiKey = '[YOUR_SHOPIFY_API_KEY]',
    ApiSecret = '[YOUR_SHOPIFY_API_SECRET]'
WHERE Domain = 'store1.myshopify.com';
```

#### 方法B: 設定ファイルで複数定義（非推奨）

```json
{
  "ShopifyApps": {
    "Public": {
      "ApiKey": "公開アプリのAPIキー",
      "ApiSecret": "環境変数で設定"
    },
    "Custom": {
      "ApiKey": "カスタムアプリのAPIキー", 
      "ApiSecret": "環境変数で設定"
    }
  }
}
```

**問題点**: どのストアがどのアプリを使うかのマッピングが複雑になる

### フロントエンドは環境変数で切り替え

```bash
# 公開アプリ用デプロイ
NEXT_PUBLIC_SHOPIFY_API_KEY=YOUR_PUBLIC_APP_API_KEY

# カスタムアプリ用デプロイ
NEXT_PUBLIC_SHOPIFY_API_KEY=YOUR_CUSTOM_APP_API_KEY
```

**注意**: フロントエンドのAPI Keyは主にShopify App Bridgeの初期化に使用されます。OAuth認証フロー自体はバックエンドで処理されるため、バックエンドが適切なAPI Key/Secretを選択します。

---

## 実装手順（パターン2）

### ステップ1: 既存実装の確認

1. `Store`テーブルに`ApiKey`と`ApiSecret`フィールドが存在することを確認
2. 既存のOAuth認証フローを確認（`ShopifyAuthController.cs`）

### ステップ2: バックエンドの修正

1. `ShopifyDbContext.cs`に`ShopifyApp`のDbSetを追加、リレーション設定
2. `ShopifyAuthController.cs`の`GetShopifyCredentialsAsync`メソッドを修正（ShopifyAppsテーブル優先）
3. `Install`メソッドを修正（apiKeyパラメータの追加、ShopifyAppsテーブル検索）
4. `Callback`メソッドを修正（stateからShopifyAppIdを取得）
5. `SaveOrUpdateStore`メソッドを修正（ShopifyAppIdの設定）
6. エラーハンドリングとログ出力を追加

### ステップ3: データベースへの設定

1. 初期データの投入（ShopifyAppsテーブル）
   ```sql
   -- 公開アプリの登録
   INSERT INTO [dbo].[ShopifyApps] 
       ([Name], [DisplayName], [AppType], [ApiKey], [ApiSecret], [AppUrl], [IsActive], [CreatedAt], [UpdatedAt])
   VALUES 
       ('EC Ranger', 'EC Ranger - 公開アプリ', 'Public', 
        '[YOUR_PUBLIC_APP_API_KEY]', '[YOUR_PUBLIC_APP_API_SECRET]', 
        'https://ec-ranger-frontend-public.azurestaticapps.net', 
        1, GETUTCDATE(), GETUTCDATE());
   
   -- カスタムアプリの登録
   INSERT INTO [dbo].[ShopifyApps] 
       ([Name], [DisplayName], [AppType], [ApiKey], [ApiSecret], [AppUrl], [IsActive], [CreatedAt], [UpdatedAt])
   VALUES 
       ('EC Ranger Demo', 'EC Ranger - カスタムアプリ', 'Custom', 
        '[YOUR_CUSTOM_APP_API_KEY]', '[YOUR_CUSTOM_APP_API_SECRET]', 
        'https://ec-ranger-frontend-custom.azurestaticapps.net', 
        1, GETUTCDATE(), GETUTCDATE());
   ```

2. 既存ストアへのShopifyAppId設定（オプション）
   ```sql
   -- 公開アプリを使用するストア
   UPDATE Stores 
   SET ShopifyAppId = (SELECT TOP 1 [Id] FROM [dbo].[ShopifyApps] WHERE [AppType] = 'Public')
   WHERE Domain = 'review-store.myshopify.com';
   ```

3. 動作確認

### ステップ4: セキュリティ強化（オプション）

1. `ApiSecret`の暗号化を実装（Phase 2）
2. Azure Key Vaultの活用を検討（Phase 3）

---

## 今すぐやるべきこと

現在のエラーを解決するため、まずは**1セット**で動作確認：

### 1. 使用するShopifyアプリを決定

**EC Ranger-demo**（カスタムアプリ）を使用：
- Client ID: `YOUR_CUSTOM_APP_CLIENT_ID`
- Client Secret: 環境変数 `Shopify__ApiSecret` で管理（ドキュメントには記載しない）

### 2. Azure Static Web Apps の環境変数を修正

```
NEXT_PUBLIC_API_URL=https://your-backend-url.azurewebsites.net
NEXT_PUBLIC_SHOPIFY_API_KEY=YOUR_CUSTOM_APP_API_KEY
```

### 3. Shopify Partners の設定を確認

**EC Ranger-demo** の設定：

| 項目 | 値 |
|------|-----|
| App URL | `https://white-island-08e0a6300.2.azurestaticapps.net/install` |
| Allowed redirection URLs | 下記参照 |

```
https://white-island-08e0a6300.2.azurestaticapps.net/api/shopify/callback
https://white-island-08e0a6300.2.azurestaticapps.net/auth/success
https://ec-ranger-backend-prod-ghf3bbarghcwh4gn.japanwest-01.azurewebsites.net/api/shopify/callback
```

### 4. 動作確認

1. フロントエンドを再ビルド・再デプロイ
2. インストールフローを検証
3. 動作確認後、公開アプリの設定を追加

### 5. 将来的な対応

データベースベースのCredentials管理を実装し、複数アプリに対応

---

## 補足: パターン2の実装詳細

### バックエンドの識別方法

**❌ 誤解**: 「リクエストヘッダーでアプリを識別」

**✅ 正解**: 「ストアドメインに基づいてデータベースからAPI Key/Secretを取得」

OAuth認証フローでは：
1. ユーザーがストアドメインを入力（例: `fuk-dev1.myshopify.com`）
2. バックエンドが `/api/shopify/install?shop=fuk-dev1.myshopify.com` を呼び出し
3. バックエンドがデータベースから `fuk-dev1.myshopify.com` のストア情報を取得
4. ストア情報に `ApiKey` と `ApiSecret` が保存されていれば使用
5. 保存されていない場合は、環境変数のデフォルト値を使用

### フロントエンドの役割

フロントエンドの `NEXT_PUBLIC_SHOPIFY_API_KEY` は：
- Shopify App Bridgeの初期化に使用
- 埋め込みアプリとして動作する際に使用
- OAuth認証フロー自体はバックエンドで処理されるため、バックエンドが適切なAPI Key/Secretを選択

---

## まとめ

| パターン | コスト | 実装難易度 | 管理のしやすさ | 推奨度 |
|---------|--------|-----------|--------------|--------|
| パターン1（完全分離） | 高（2倍） | 低 | 低 | ⭐⭐⭐ |
| パターン2（バックエンド共有） | 中 | 中 | 高 | ⭐⭐⭐⭐⭐ |
| パターン3（完全共有） | 低 | 高 | 中 | ⭐（非推奨） |

**結論**: パターン2（バックエンド共有）を推奨します。データベースベースのCredentials管理を実装することで、1つのバックエンドで複数のShopifyアプリ（公開/カスタム）に対応できます。

---

## 関連ドキュメント

- `マルチアプリ対応アーキテクチャ.md` - 全体アーキテクチャ
- `マルチCredentials管理方法.md` - Credentials管理の詳細
- `アプリインストールガイド.md` - OAuth認証フローの詳細

---

## 更新履歴

| 日付 | 内容 |
|------|------|
| 2025-12-22 | 初版作成 |
| 2025-12-22 | 既存実装の確認セクション追加、データベーススキーマの確認セクション追加、セキュリティ考慮事項追加、実装手順追加 |

