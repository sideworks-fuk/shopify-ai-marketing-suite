# 公開アプリとカスタムアプリの両方に対応するアーキテクチャ

## 質問
公開アプリとカスタムアプリの両方を作りたい場合、フロントエンドとバックエンドのアプリも複数作る必要があるか？

## 回答

### ✅ **推奨: 同じインフラを使い回す（コスト効率が良い）**

**同じフロントエンド・バックエンドを使い回すことが可能です。**

### 現在の実装状況

1. **データベース構造**: `Store` テーブルに `ApiKey` と `ApiSecret` フィールドが存在
   - ストアごとに異なるAPI Key/Secretを保存可能
   - マルチテナント対応の基盤は整っている

2. **現在の制限**: 
   - OAuth認証時に設定ファイルから1つのAPI Key/Secretのみを読み込んでいる
   - ストアごとのAPI Key/Secretを使用するにはコード修正が必要

### 実装方法（選択肢）

## 方法1: データベースベースのマルチアプリ対応（推奨）

### メリット
- ✅ 1つのインフラで複数のアプリ（公開/カスタム）に対応
- ✅ コスト効率が良い（追加のAzureリソース不要）
- ✅ データベースでストアごとのAPI Key/Secretを管理
- ✅ 将来的な拡張性が高い

### 必要な修正

1. **OAuth認証フローの修正**
   - インストール時に、ストアドメインに基づいてデータベースからAPI Key/Secretを取得
   - または、OAuthコールバック時にストア情報とAPI Key/Secretを関連付け

2. **データベース設計**
   - `Store` テーブルの `ApiKey` と `ApiSecret` フィールドを活用
   - ストア作成時に、対応するShopifyアプリのAPI Key/Secretを保存

3. **設定ファイルの変更**
   - デフォルトのAPI Key/Secretは設定ファイルに残す（フォールバック用）
   - ストア固有のAPI Key/Secretはデータベースから取得

### 実装例（概念）

```csharp
// ShopifyAuthController.cs の修正例
private string GetApiKeyForStore(string shopDomain)
{
    // 1. データベースからストア情報を取得
    var store = _context.Stores.FirstOrDefault(s => s.Domain == shopDomain);
    
    // 2. ストア固有のAPI Keyがあれば使用
    if (store != null && !string.IsNullOrEmpty(store.ApiKey))
    {
        return store.ApiKey;
    }
    
    // 3. フォールバック: 設定ファイルから取得
    return GetShopifySetting("ApiKey");
}
```

## 方法2: 別々のインフラを作る

### メリット
- ✅ 完全に分離された環境
- ✅ セキュリティ境界が明確
- ✅ 障害の影響範囲を限定できる

### デメリット
- ❌ コストが2倍になる（App Service、Static Web Apps、SQL Database）
- ❌ デプロイメントが複雑になる
- ❌ メンテナンス負荷が増える

### 構成例

```
公開アプリ用:
- Frontend: white-island-08e0a6300.1.azurestaticapps.net
- Backend: ec-ranger-backend-public.japanwest-01.azurewebsites.net
- Database: ec-ranger-db-public

カスタムアプリ用:
- Frontend: white-island-08e0a6300.2.azurestaticapps.net
- Backend: ec-ranger-backend-custom.japanwest-01.azurewebsites.net
- Database: ec-ranger-db-custom
```

## 推奨アプローチ

### 短期（現在）
**方法1（データベースベース）を推奨**

理由：
- 既存のデータベース構造が対応可能
- コスト効率が良い
- 実装が比較的簡単

### 実装手順

1. **データベースにストア情報を保存する際にAPI Key/Secretも保存**
   ```sql
   UPDATE Stores 
   SET ApiKey = 'YOUR_SHOPIFY_API_KEY',
       ApiSecret = 'YOUR_SHOPIFY_API_SECRET'
   WHERE Domain = 'fuk-dev1.myshopify.com';
   ```

2. **OAuth認証フローを修正**
   - `ShopifyAuthController.cs` の `GetShopifySetting()` を拡張
   - ストアドメインに基づいてデータベースからAPI Key/Secretを取得

3. **フロントエンドは変更不要**
   - 同じフロントエンドを使用
   - バックエンドが適切なAPI Key/Secretを選択

### 長期（将来）
**方法2（別々のインフラ）を検討**

以下の場合に検討：
- 公開アプリとカスタムアプリで異なる機能を提供する必要がある
- セキュリティ要件が厳しい
- スケール要件が異なる

## 現在の実装での対応

### 現状（1つのAPI Keyのみ）

現在は、設定ファイル（`appsettings.Production.json`）から1つのAPI Key/Secretを読み込んでいます：

```json
"Shopify": {
  "ApiKey": "YOUR_SHOPIFY_API_KEY",
  "ApiSecret": "Will be overridden by environment variable"
}
```

### 対応方法

#### オプションA: 環境変数で切り替え（簡単だが制限あり）
- 公開アプリ用とカスタムアプリ用で異なる環境変数を設定
- デプロイ時に環境変数を切り替え
- **制限**: 同時に両方のアプリをサポートできない

#### オプションB: データベースベース（推奨）
- ストアごとにAPI Key/Secretをデータベースに保存
- OAuth認証時にデータベースから取得
- **メリット**: 同時に複数のアプリをサポート可能

## まとめ

| 項目 | 方法1（データベース） | 方法2（別インフラ） |
|------|---------------------|-------------------|
| コスト | 低い（1セット） | 高い（2セット） |
| 実装難易度 | 中（コード修正必要） | 低（設定のみ） |
| メンテナンス | 簡単 | 複雑 |
| スケーラビリティ | 高い | 中 |
| セキュリティ | 中 | 高い |

**推奨**: 方法1（データベースベース）で実装し、将来的に必要に応じて方法2に移行

## 関連ドキュメント
- `アプリインストールガイド.md` - OAuth認証フローの詳細
- `system-architecture.md` - システムアーキテクチャ全体

