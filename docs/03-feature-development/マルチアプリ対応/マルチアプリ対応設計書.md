# マルチアプリ対応設計書

## 1. 概要

### 1.1 目的
公開アプリとカスタムアプリの両方に対応するため、1つのバックエンド・データベースで複数のShopifyアプリ（異なるAPI Key/Secret）を管理できるようにする。

### 1.2 設計方針
- **データベースベースのCredentials管理**（推奨アプローチ）
- ストアごとに異なるAPI Key/Secretをデータベースで管理
- 後方互換性を維持（既存ストアはデフォルトCredentialsで動作）

### 1.3 前提条件
- `Store`テーブルに`ApiKey`と`ApiSecret`フィールドが既に存在
- 既存のOAuth認証フローが動作している
- フロントエンドは変更不要（バックエンドが適切なCredentialsを選択）

---

## 2. 現在の実装状況

### 2.1 データベーススキーマ
```sql
-- Storesテーブル
ApiKey      nvarchar(255) NULL  -- ストア固有のShopify API Key
ApiSecret   nvarchar(255) NULL  -- ストア固有のShopify API Secret
AccessToken nvarchar(max) NULL   -- アクセストークン（暗号化済み）
```

### 2.2 既存実装
- ✅ `GetShopifyCredentialsAsync`メソッドが実装済み
  - データベース優先、フォールバックは設定ファイル/環境変数
  - エラーハンドリングとログ出力も実装済み
- ✅ `SaveOrUpdateStore`メソッドが実装済み
  - アクセストークンの保存機能あり（暗号化済み）
  - ✅ API Key/Secretの保存機能も実装済み（既存Credentials保護機能付き）
- ✅ `EncryptToken`メソッドが実装済み
  - AES暗号化を使用（AccessToken用）
  - ApiSecretの暗号化は未実装（Phase 2で対応予定）

### 2.3 設定ファイル
```json
// appsettings.Production.json
{
  "Shopify": {
    "ApiKey": "[デフォルトのAPI Key]",
    "ApiSecret": "[環境変数で設定]",
    "Scopes": "read_orders,read_products,read_customers"
  }
}
```

---

## 3. 設計詳細

### 3.1 アーキテクチャ概要

```
┌─────────────────────────────────────────────────────────┐
│ Shopifyアプリ                                            │
│  ├─ EC Ranger（公開）→ API Key: AAA                      │
│  └─ EC Ranger-demo（カスタム）→ API Key: BBB             │
└─────────────────────────────────────────────────────────┘
            ↓                    ↓
┌───────────────────┐   ┌───────────────────┐
│ フロントエンド（公開）│   │ フロントエンド（カスタム）│
│ NEXT_PUBLIC_      │   │ NEXT_PUBLIC_      │
│ SHOPIFY_API_KEY=  │   │ SHOPIFY_API_KEY=  │
│ AAA               │   │ BBB               │
└───────────────────┘   └───────────────────┘
            ↓                    ↓
┌─────────────────────────────────────────────────────────┐
│ バックエンド（共有）                                      │
│                                                         │
│ 1. Install: GetShopifyCredentialsAsync(shop)           │
│    → データベースから取得（なければ設定ファイル）         │
│                                                         │
│ 2. Callback: ExchangeCodeForAccessToken(code, shop)     │
│    → 使用したAPI Key/Secretでトークン取得               │
│                                                         │
│ 3. SaveOrUpdateStore(shop, token, apiKey, apiSecret)   │
│    → ストア情報とCredentialsを保存                       │
└─────────────────────────────────────────────────────────┘
            ↓
┌─────────────────────────────────────────────────────────┐
│ データベース（共有）                                      │
│                                                         │
│ Storesテーブル:                                         │
│  - store1.myshopify.com → ApiKey: AAA, ApiSecret: XXX  │
│  - store2.myshopify.com → ApiKey: BBB, ApiSecret: YYY  │
│  - store3.myshopify.com → ApiKey: NULL (デフォルト使用) │
└─────────────────────────────────────────────────────────┘
```

### 3.2 データフロー

#### 3.2.1 インストール開始時（`/api/shopify/install`）

```
1. ユーザーが /install?shop=store1.myshopify.com にアクセス
   ↓
2. GetShopifyCredentialsAsync("store1.myshopify.com")
   ├─ データベースからストア情報を取得
   ├─ ApiKey/ApiSecretが存在 → 使用
   └─ 存在しない → 設定ファイルから取得（フォールバック）
   ↓
3. Shopify OAuth URLを構築（取得したAPI Keyを使用）
   ↓
4. ユーザーをShopify認証ページにリダイレクト
```

#### 3.2.2 OAuth認証完了時（`/api/shopify/callback`）

```
1. Shopifyからコールバック（code, shop, state）
   ↓
2. GetShopifyCredentialsAsync(shop)
   ├─ データベースから取得（インストール時に保存済みの場合）
   └─ または設定ファイルから取得（初回インストール時）
   ↓
3. ExchangeCodeForAccessToken(code, shop, apiKey, apiSecret)
   ├─ アクセストークンを取得
   └─ 使用したAPI Key/Secretを記録
   ↓
4. SaveOrUpdateStore(shop, accessToken, apiKey, apiSecret)
   ├─ ストア情報を保存/更新
   ├─ アクセストークンを暗号化して保存
   └─ API Key/Secretが未保存の場合のみ保存
   ↓
5. Webhook登録
```

### 3.3 クラス設計

#### 3.3.1 `GetShopifyCredentialsAsync`メソッド

**責務**: ストアドメインに基づいてShopify Credentialsを取得

**優先順位**:
1. データベースからストア固有のCredentialsを取得
2. 存在しない場合は設定ファイル/環境変数から取得（フォールバック）

**シグネチャ**:
```csharp
private async Task<(string ApiKey, string ApiSecret)> GetShopifyCredentialsAsync(string shopDomain)
```

**実装ロジック**:
```csharp
1. データベースからストア情報を取得（Domainで検索）
2. ストア固有のApiKey/ApiSecretが存在するか確認
3. 存在する場合:
   - ログ出力: "ストア固有のCredentialsを使用"
   - (store.ApiKey, store.ApiSecret) を返す
4. 存在しない場合:
   - ログ出力: "デフォルトCredentialsを使用"
   - GetShopifySetting("ApiKey") / GetShopifySetting("ApiSecret") を返す
5. エラー時:
   - ログ出力: "エラー発生、フォールバックを使用"
   - 設定ファイルから取得して返す
```

#### 3.3.2 `SaveOrUpdateStore`メソッド

**責務**: ストア情報とOAuth認証情報をデータベースに保存/更新

**シグネチャ**:
```csharp
private async Task SaveOrUpdateStore(
    string shopDomain, 
    string accessToken, 
    string? apiKey = null, 
    string? apiSecret = null)
```

**実装ロジック**:
```csharp
1. 既存のストアを検索（Domainで検索）
2. 存在しない場合:
   - 新規ストアを作成
   - ApiKey/ApiSecretが提供されていれば保存
3. 存在する場合:
   - 既存のストア情報を更新
   - ApiKey/ApiSecretが提供され、かつ既存値がNULLの場合のみ保存
     （既存のCredentialsを保護）
4. アクセストークンを暗号化して保存
5. UpdatedAtを更新
6. データベースに保存
```

**重要な設計判断**:
- **既存のCredentialsは上書きしない**: データベースに既に保存されているApiKey/ApiSecretは保護する
- **新規ストアのみ保存**: 初回インストール時のみ、使用したAPI Key/Secretを保存
- **オプショナルパラメータ**: apiKey/apiSecretはオプション（後方互換性のため）

#### 3.3.3 `ExchangeCodeForAccessToken`メソッド

**責務**: 認証コードをアクセストークンに交換

**変更点**: 既存実装を維持（`GetShopifyCredentialsAsync`を使用）

**実装ロジック**:
```csharp
1. GetShopifyCredentialsAsync(shop) でAPI Key/Secretを取得
2. Shopify APIにリクエスト送信
3. アクセストークンを取得
4. トークンを返す
```

---

## 4. セキュリティ考慮事項

### 4.1 現在の実装（Phase 1）

#### 4.1.1 データベース保存
- **ApiKey**: 平文で保存（nvarchar(255)）
- **ApiSecret**: 平文で保存（nvarchar(255)）
- **AccessToken**: 暗号化して保存（`EncryptToken`メソッド使用）

#### 4.1.2 セキュリティ対策
- ✅ データベースアクセス制限（Azure SQL Databaseのファイアウォール設定）
- ✅ ログにAPI Secretが出力されないように注意
- ⚠️ ApiSecretの暗号化は未実装（Phase 2で対応予定）

### 4.2 将来の改善（Phase 2）

#### 4.2.1 ApiSecretの暗号化
```csharp
// ASP.NET Core Data Protectionを使用
public class StoreService
{
    private readonly IDataProtector _protector;
    
    public StoreService(IDataProtectionProvider provider)
    {
        _protector = provider.CreateProtector("ShopifyApiSecrets");
    }
    
    public string EncryptSecret(string secret) => _protector.Protect(secret);
    public string DecryptSecret(string encrypted) => _protector.Unprotect(encrypted);
}
```

#### 4.2.2 Azure Key Vaultの活用（Phase 3）
- 各ストアのAPI SecretをAzure Key Vaultに保存
- 動的なシークレットローテーション

---

## 5. エラーハンドリング

### 5.1 エラーケースと対応

| エラーケース | 対応方法 |
|------------|---------|
| データベースからストア情報取得失敗 | ログ出力後、設定ファイルから取得（フォールバック） |
| API Keyが見つからない | エラーログ出力、500エラーを返す |
| API Secretが見つからない | エラーログ出力、500エラーを返す |
| アクセストークン取得失敗 | リトライ機能を使用（既存実装） |
| ストア情報保存失敗 | エラーログ出力、例外をスロー |

### 5.2 ログ出力方針

```csharp
// 正常系
_logger.LogInformation("ストア固有のCredentialsを使用. Shop: {Shop}", shopDomain);
_logger.LogInformation("デフォルトCredentialsを使用（設定ファイル/環境変数）. Shop: {Shop}", shopDomain);
_logger.LogInformation("ストア情報を保存しました. Shop: {Shop}, HasApiKey: {HasApiKey}, HasApiSecret: {HasApiSecret}", 
    shopDomain, !string.IsNullOrEmpty(store.ApiKey), !string.IsNullOrEmpty(store.ApiSecret));

// エラー系
_logger.LogError("API Keyが見つかりません. Shop: {Shop}", shopDomain);
_logger.LogError(ex, "Credentials取得中にエラーが発生. Shop: {Shop}, フォールバックを使用", shopDomain);
_logger.LogError(ex, "ストア情報の保存中にエラーが発生. Shop: {Shop}", shopDomain);
```

---

## 6. データベース操作

### 6.1 ストア作成時のCredentials設定

#### 6.1.1 手動設定（管理画面またはSQL）

```sql
-- 公開アプリ用ストア
UPDATE Stores 
SET ApiKey = '[YOUR_PUBLIC_APP_API_KEY]',
    ApiSecret = '[YOUR_PUBLIC_APP_API_SECRET]'
WHERE Domain = 'public-store.myshopify.com';

-- カスタムアプリ用ストア
UPDATE Stores 
SET ApiKey = '[YOUR_CUSTOM_APP_API_KEY]',
    ApiSecret = '[YOUR_CUSTOM_APP_API_SECRET]'
WHERE Domain = 'custom-store.myshopify.com';
```

#### 6.1.2 自動設定（OAuth認証時）

- 初回インストール時に、使用したAPI Key/Secretを自動保存
- 既存ストアのCredentialsは上書きしない（保護）

### 6.2 クエリパフォーマンス

- `Domain`カラムにインデックスが必要（既存実装で確認済み）
- `FirstOrDefaultAsync`を使用して1件のみ取得（効率的）

---

## 7. 実装手順

### 7.1 Phase 1: 基本実装（現在）

#### ステップ1: `SaveOrUpdateStore`メソッドの拡張
- [x] メソッドシグネチャに`apiKey`と`apiSecret`パラメータを追加
- [x] 既存のCredentialsを保護するロジックを実装
- [x] 新規ストアの場合のみ、API Key/Secretを保存

#### ステップ2: OAuth認証フローの修正
- [x] `Callback`メソッドで使用したAPI Key/Secretを取得
- [x] `ProcessCallback`メソッドで使用したAPI Key/Secretを取得
- [x] `SaveOrUpdateStore`にAPI Key/Secretを渡す

#### ステップ3: 動作確認（実装前の確認事項）
- [ ] 実装の動作確認とテスト計画の策定
- [ ] 異なるAPI Key/Secretを持つストアでOAuth認証をテスト
- [ ] データベースにCredentialsが正しく保存されることを確認
- [ ] 既存ストアのCredentialsが保護されることを確認
- [ ] エラーハンドリングの動作確認

### 7.2 Phase 2: セキュリティ強化（将来）

#### ステップ1: ApiSecretの暗号化
- [ ] ASP.NET Core Data Protectionを設定
- [ ] `StoreService`に暗号化/復号化メソッドを追加
- [ ] `SaveOrUpdateStore`で暗号化して保存

#### ステップ2: 既存データの移行
- [ ] 既存の平文ApiSecretを暗号化
- [ ] データ移行スクリプトの作成

### 7.3 Phase 3: 高度な機能（将来）

#### ステップ1: Azure Key Vault統合
- [ ] Azure Key Vaultへの接続設定
- [ ] 各ストアのAPI SecretをKey Vaultに保存
- [ ] 動的なシークレット取得機能

---

## 8. テスト方針

### 8.1 単体テスト

#### 8.1.1 `GetShopifyCredentialsAsync`メソッド
- データベースにストア固有のCredentialsが存在する場合
- データベースにCredentialsが存在しない場合（フォールバック）
- データベースアクセスエラーの場合

#### 8.1.2 `SaveOrUpdateStore`メソッド
- 新規ストア作成時にAPI Key/Secretを保存
- 既存ストアのCredentialsを保護（上書きしない）
- アクセストークンの暗号化保存

### 8.2 統合テスト

#### 8.2.1 OAuth認証フロー
- 公開アプリ用API Key/Secretでの認証
- カスタムアプリ用API Key/Secretでの認証
- デフォルトCredentialsでの認証（後方互換性）

#### 8.2.2 データベース操作
- ストア情報の保存/更新
- Credentialsの保存/保護

### 8.3 エンドツーエンドテスト

#### 8.3.1 インストールフロー
1. 公開アプリ用ストアでインストール
2. カスタムアプリ用ストアでインストール
3. デフォルトCredentialsでインストール

#### 8.3.2 動作確認
- 各ストアで正しいAPI Key/Secretが使用されること
- データベースにCredentialsが正しく保存されること

---

## 9. 移行計画

### 9.1 既存ストアへの対応

#### 9.1.1 後方互換性
- 既存ストアはデフォルトCredentialsで動作（変更不要）
- データベースにApiKey/ApiSecretがNULLの場合は、設定ファイルから取得

#### 9.1.2 段階的移行
1. **Phase 1**: 新規ストアのみ、データベースにCredentialsを保存
2. **Phase 2**: 既存ストアにも必要に応じてCredentialsを設定
3. **Phase 3**: すべてのストアがデータベースベースのCredentialsを使用

### 9.2 データ移行

#### 9.2.1 手動設定
- 管理画面またはSQLで既存ストアにCredentialsを設定
- 設定後は、次回のOAuth認証から新しいCredentialsが使用される

#### 9.2.2 自動移行（オプション）
- 初回のOAuth認証時に、使用したAPI Key/Secretを自動保存
- 既存のCredentialsは保護（上書きしない）

---

## 10. 運用・保守

### 10.1 モニタリング

#### 10.1.1 ログ監視
- Credentials取得時のログ（ストア固有 vs デフォルト）
- エラー発生時のログ
- ストア情報保存時のログ

#### 10.1.2 メトリクス
- ストア固有Credentials使用率
- デフォルトCredentials使用率
- エラー発生率

### 10.2 トラブルシューティング

#### 10.2.1 よくある問題

**問題**: ストア固有のCredentialsが使用されない
- **原因**: データベースにApiKey/ApiSecretが保存されていない
- **対応**: SQLで手動設定、またはOAuth認証を再実行

**問題**: OAuth認証が失敗する
- **原因**: API Key/Secretが無効
- **対応**: Shopify PartnersでAPI Key/Secretを確認、データベースを更新

### 10.3 ドキュメント

#### 10.3.1 運用マニュアル
- Credentials設定方法
- トラブルシューティング手順
- セキュリティベストプラクティス

---

## 11. 関連ドキュメント

- `マルチアプリ対応アーキテクチャ.md` - 全体アーキテクチャ
- `マルチCredentials管理方法.md` - Credentials管理の詳細
- `公開アプリとカスタムアプリの構成パターン.md` - 構成パターンの比較
- `アプリインストールガイド.md` - OAuth認証フローの詳細

---

## 12. 実装前の確認事項

### 12.1 設計の要点

#### 12.1.1 重要な設計判断

1. **既存Credentialsの保護**
   - データベースに既に保存されているApiKey/ApiSecretは上書きしない
   - 新規ストアまたはNULLの場合のみ保存
   - 理由: 手動で設定したCredentialsを誤って上書きすることを防ぐ

2. **フォールバック機構**
   - データベースにCredentialsが存在しない場合は、設定ファイル/環境変数から取得
   - 理由: 既存ストアの後方互換性を維持

3. **オプショナルパラメータ**
   - `SaveOrUpdateStore`の`apiKey`と`apiSecret`はオプショナル
   - 理由: 既存コードとの互換性を維持

#### 12.1.2 セキュリティ考慮事項

**Phase 1（現在）**:
- ApiKey: 平文で保存（nvarchar(255)）
- ApiSecret: 平文で保存（nvarchar(255)）
- AccessToken: 暗号化して保存（既存実装）

**Phase 2（将来）**:
- ApiSecretの暗号化を実装
- ASP.NET Core Data Protectionを使用

**Phase 3（将来）**:
- Azure Key Vaultに移行

### 12.2 実装前チェックリスト

#### 12.2.1 コード実装
- [x] `GetShopifyCredentialsAsync`メソッドの実装確認
- [x] `SaveOrUpdateStore`メソッドの拡張確認
- [x] OAuth認証フローの修正確認
- [ ] エラーハンドリングの確認
- [ ] ログ出力の確認

#### 12.2.2 データベース
- [x] `Store`テーブルに`ApiKey`と`ApiSecret`フィールドが存在
- [ ] `Domain`カラムにインデックスが設定されているか確認
- [ ] 既存データのバックアップ

#### 12.2.3 設定
- [ ] デフォルトのAPI Key/Secretが環境変数に設定されているか確認
- [ ] テスト用のAPI Key/Secretが準備されているか確認

### 12.3 実装後の検証項目

#### 12.3.1 機能検証
1. **新規ストアのインストール**
   - データベースにCredentialsが保存されること
   - 次回のOAuth認証で保存されたCredentialsが使用されること

2. **既存ストアの再認証**
   - 既存のCredentialsが保護されること（上書きされないこと）
   - デフォルトCredentialsが使用されること（データベースにNULLの場合）

3. **エラーケース**
   - API Keyが見つからない場合のエラーハンドリング
   - データベースアクセスエラー時のフォールバック

#### 12.3.2 パフォーマンス検証
- データベースクエリの実行時間
- ログ出力のパフォーマンス影響

---

## 13. 更新履歴

| 日付 | バージョン | 変更内容 | 作成者 |
|------|----------|---------|--------|
| 2025-01-XX | 1.0 | 初版作成 | 福田＋AI Assistant |

