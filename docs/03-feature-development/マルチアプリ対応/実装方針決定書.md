# マルチアプリ対応実装方針決定書

## 決定事項

**パターン2: バックエンド共有（データベースベースのCredentials管理）を採用**

---

## 1. 採用パターンの概要

### パターン2: バックエンド共有（推奨・採用）

```
┌─────────────────────────────────────────────────────────┐
│ Shopifyアプリ                                            │
│  ├─ EC Ranger（公開）→ API Key: AAA                      │
│  └─ EC Ranger-demo（カスタム）→ API Key: BBB             │
└─────────────────────────────────────────────────────────┘
            ↓                    ↓
┌───────────────────┐   ┌───────────────────┐
│ フロントエンド（公開）│   │ フロントエンド（カスタム）│
│ NEXT_PUBLIC_      │   │ NEXT_PUBLIC_      │
│ SHOPIFY_API_KEY=  │   │ SHOPIFY_API_KEY=  │
│ AAA               │   │ BBB               │
└───────────────────┘   └───────────────────┘
            ↓                    ↓
┌─────────────────────────────────────────────────────────┐
│ バックエンド（共有）                                      │
│ - ストアドメインに基づいてデータベースから                │
│   API Key/Secretを取得                                   │
│ - データベースに保存されていない場合は                    │
│   環境変数のデフォルト値を使用                            │
│ - 1つのデータベースで全ストアを管理                      │
└─────────────────────────────────────────────────────────┘
```

---

## 2. 採用理由

### 2.1 コスト効率
- ✅ **バックエンドコスト削減**: 1つのApp Serviceで運用
- ✅ **データベースコスト削減**: 1つのSQL Databaseで運用
- ✅ **管理コスト削減**: デプロイメント、環境変数設定が1セットで済む

### 2.2 実装の容易さ
- ✅ **既存インフラを活用**: 追加のAzureリソース不要
- ✅ **データベーススキーマ変更不要**: `ApiKey`と`ApiSecret`フィールドが既に存在
- ✅ **段階的な移行が可能**: 既存ストアはデフォルトCredentialsで動作

### 2.3 スケーラビリティ
- ✅ **無制限のアプリ対応**: データベースに保存するため、アプリ数の制限なし
- ✅ **動的な追加・削除**: SQLで更新可能（再デプロイ不要）
- ✅ **柔軟な管理**: ストアごとに異なるCredentialsを設定可能

### 2.4 メンテナンス性
- ✅ **ビジネスロジック共有**: 1つのコードベースで管理
- ✅ **バグ修正の効率化**: 1箇所の修正で全アプリに反映
- ✅ **テストの簡素化**: 1つの環境でテスト可能

---

## 3. 他のパターンとの比較

### 3.1 パターン1: 完全分離（採用しなかった理由）

| 項目 | 評価 |
|------|------|
| コスト | ❌ 2倍（App Service、Static Web Apps、SQL Database） |
| 管理 | ❌ デプロイ、環境変数設定が2倍 |
| メンテナンス | ❌ コードの同期が必要 |

**採用しなかった理由**: コストと管理負荷が高すぎる。現時点では過剰な分離。

### 3.2 パターン3: 完全共有（採用しなかった理由）

| 項目 | 評価 |
|------|------|
| Shopify審査 | ❌ App URLが同じになり審査で問題の可能性 |
| 実装 | ❌ 複雑（URLパラメータでの切り替えが必要） |

**採用しなかった理由**: Shopify Partnersの要件上、各アプリに異なるApp URLが必要。パターン3では実現困難。

---

## 4. 実装構成

### 4.1 インフラ構成

| リソース | 構成 | 説明 |
|---------|------|------|
| **バックエンド** | 1つ（共有） | `ec-ranger-backend-prod` |
| **データベース** | 1つ（共有） | `ec-ranger-db-prod` |
| **フロントエンド** | 2つ（推奨） | 公開アプリ用とカスタムアプリ用で別々にデプロイ |

### 4.2 フロントエンドのデプロイ方法

**推奨: 別々のStatic Web Appsリソースを作成**

```
┌─────────────────────────────────────────────────────────┐
│ ec-ranger-frontend-public                                │
│  └─ 環境変数: NEXT_PUBLIC_SHOPIFY_API_KEY=公開用APIキー  │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│ ec-ranger-frontend-custom                                │
│  └─ 環境変数: NEXT_PUBLIC_SHOPIFY_API_KEY=カスタム用APIキー │
└─────────────────────────────────────────────────────────┘
```

**理由**:
- 各アプリに異なるApp URLを設定可能（Shopify Partnersの要件）
- 環境変数の管理が明確
- デプロイの独立性を確保

### 4.3 データベース管理

**ストアごとに異なるCredentialsを管理**

```sql
-- 公開アプリ用ストア
UPDATE Stores 
SET ApiKey = '[YOUR_PUBLIC_APP_API_KEY]',
    ApiSecret = '[YOUR_PUBLIC_APP_API_SECRET]'
WHERE Domain = 'public-store.myshopify.com';

-- カスタムアプリ用ストア
UPDATE Stores 
SET ApiKey = '[YOUR_CUSTOM_APP_API_KEY]',
    ApiSecret = '[YOUR_CUSTOM_APP_API_SECRET]'
WHERE Domain = 'custom-store.myshopify.com';
```

---

## 5. 実装状況

### 5.1 既に実装済み

- ✅ `GetShopifyCredentialsAsync`メソッド
  - データベース優先、フォールバックは設定ファイル/環境変数
  - エラーハンドリングとログ出力も実装済み

- ✅ `SaveOrUpdateStore`メソッドの拡張
  - API Key/Secretの保存機能を追加
  - 既存Credentials保護機能を実装

- ✅ OAuth認証フローの修正
  - `Callback`と`ProcessCallback`で使用したAPI Key/Secretを保存

### 5.2 実装前の確認事項

- [ ] データベースのインデックス確認（`Domain`カラム）
- [ ] テスト環境の準備
- [ ] エラーハンドリングの確認
- [ ] ログ出力の確認（API Secretが出力されていないか）

---

## 6. 実装フロー

### 6.1 OAuth認証フロー

```
[ユーザーがインストール開始]
  ↓
フロントエンド: /install?shop=store1.myshopify.com
  ↓
バックエンド: GetShopifyCredentialsAsync("store1.myshopify.com")
  ├─ データベースから取得（優先）
  └─ 存在しない → 設定ファイルから取得（フォールバック）
  ↓
Shopify OAuth URL構築（取得したAPI Keyを使用）
  ↓
[ユーザーがShopifyで認証]
  ↓
[OAuth認証完了]
  ↓
バックエンド: ExchangeCodeForAccessToken(code, shop)
  ├─ GetShopifyCredentialsAsync(shop) でAPI Key/Secretを取得
  └─ アクセストークンを取得
  ↓
バックエンド: SaveOrUpdateStore(shop, accessToken, apiKey, apiSecret)
  ├─ 新規ストア → API Key/Secretを保存
  └─ 既存ストア → 既存Credentialsを保護（上書きしない）
```

### 6.2 ストア識別方法

**ストアドメインに基づいてデータベースから取得**

- ユーザーがストアドメインを入力（例: `fuk-dev1.myshopify.com`）
- バックエンドがデータベースから該当ストアの情報を取得
- ストア情報に`ApiKey`と`ApiSecret`が保存されていれば使用
- 保存されていない場合は、環境変数のデフォルト値を使用

---

## 7. セキュリティ考慮事項

### 7.1 Phase 1（現在）

- **ApiKey**: 平文で保存（nvarchar(255)）
- **ApiSecret**: 平文で保存（nvarchar(255)）
- **AccessToken**: 暗号化して保存（既存実装）

**セキュリティ対策**:
- ✅ データベースアクセス制限（Azure SQL Databaseのファイアウォール設定）
- ✅ ログにAPI Secretが出力されないように注意
- ⚠️ ApiSecretの暗号化は未実装（Phase 2で対応予定）

### 7.2 Phase 2（将来）

- 🔒 `ApiSecret`を暗号化して保存（ASP.NET Core Data Protection使用）
- 🔒 Azure Key Vaultの活用を検討

---

## 8. メリット・デメリット

### 8.1 メリット

| 項目 | 説明 |
|------|------|
| **コスト効率** | バックエンド・データベースが1つで済む |
| **実装容易性** | 既存インフラを活用、追加リソース不要 |
| **スケーラビリティ** | 無制限のアプリ対応が可能 |
| **メンテナンス性** | 1つのコードベースで管理 |
| **後方互換性** | 既存ストアはデフォルトCredentialsで動作 |

### 8.2 デメリット・注意点

| 項目 | 説明 | 対策 |
|------|------|------|
| **バックエンド実装の複雑さ** | データベースから取得する処理が必要 | 既に実装済み |
| **フロントエンドの複数デプロイ** | 別々にデプロイする必要がある | 別々のStatic Web Appsリソースを作成 |
| **セキュリティ** | ApiSecretが平文で保存（Phase 1） | Phase 2で暗号化を実装 |

---

## 9. 次のステップ

### 9.1 実装前

1. ✅ 設計書の作成
2. ✅ 実装方針の決定
3. [ ] 実装前確認事項のチェック
4. [ ] テスト環境の準備

### 9.2 実装後

1. [ ] 機能検証
2. [ ] エラーケース検証
3. [ ] パフォーマンス検証
4. [ ] ドキュメント更新

---

## 10. 関連ドキュメント

- `マルチアプリ対応設計書.md` - 詳細設計
- `公開アプリとカスタムアプリの構成パターン.md` - パターン比較
- `マルチCredentials管理方法.md` - Credentials管理の詳細
- `実装前確認事項.md` - 実装前のチェックリスト

---

## 11. 決定日

**2025-01-XX**: パターン2（バックエンド共有）を採用

**決定者**: 福田＋AI Assistant

**承認**: 設計書レビュー後、実装開始

