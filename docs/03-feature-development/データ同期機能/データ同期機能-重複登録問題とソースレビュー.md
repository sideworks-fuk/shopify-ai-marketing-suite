# データ同期機能 - 重複登録問題とソースレビュー

**作成日**: 2026-01-19  
**レビュー対象**: データ同期機能の重複登録問題と全体アーキテクチャ

---

## 📋 概要

データ同期途中で失敗した後に再処理する場合に、データが重複登録されてしまう問題があるかどうかを調査し、データ同期機能の全体をレビューしました。

---

## 🔍 重複登録問題の調査結果

### ✅ 重複登録は発生しない（理論上）

現在の実装では、以下のキーで重複チェックを行っているため、**理論的には重複登録は発生しません**：

| テーブル | 重複チェックキー | 実装箇所 |
|---------|----------------|---------|
| **Customers** | `StoreId` + `ShopifyCustomerId` | `UpsertCustomerAsync` (ShopifyApiService.cs:600-602) |
| **Products** | `StoreId` + `ShopifyProductId` | `UpsertProductAsync` (ShopifyApiService.cs:656-659) |
| **Orders** | `StoreId` + `ShopifyOrderId` | `UpsertOrderAsync` (ShopifyApiService.cs:738-741) |

### ⚠️ 潜在的な問題点

#### 1. トランザクション管理の問題

**問題**: 各レコードごとに`SaveChangesAsync()`を呼んでいるため、途中で失敗した場合、一部のデータは保存されているが、同期ステータスが失敗になっている可能性があります。

**現在の実装** (`ShopifyApiService.cs`):
```csharp
private async Task UpsertCustomerAsync(int storeId, ShopifyCustomer customer)
{
    var existingCustomer = await _context.Customers
        .FirstOrDefaultAsync(c => c.StoreId == storeId && 
                                 c.ShopifyCustomerId == customer.Id.ToString());
    
    if (existingCustomer != null)
    {
        // 更新
        // ...
    }
    else
    {
        // 新規作成
        _context.Customers.Add(newCustomer);
    }
    
    await _context.SaveChangesAsync(); // ⚠️ 各レコードごとに保存
}
```

**影響**:
- 同期が途中で失敗した場合、一部のデータは保存されている
- 再実行時に、保存済みのデータは更新される（重複は発生しない）
- ただし、パフォーマンスの問題がある（各レコードごとにDBアクセス）

#### 2. チェックポイント管理の問題

**問題**: 新しいジョブクラス（`ShopifyProductSyncJob`など）では、バッチ処理後にチェックポイントを保存していますが、バッチ保存とチェックポイント保存の間に失敗した場合、チェックポイントが保存されず、次回は最初からやり直すことになります。

**現在の実装** (`ShopifyProductSyncJob.cs`):
```csharp
// バッチサイズに達したら保存
if (batch.Count >= batchSize)
{
    await SaveOrUpdateProductsBatch(storeId, batch); // データベースに保存
    syncedCount += batch.Count;
    totalProcessed += batch.Count;
    batch.Clear();
    
    // 進捗を更新
    await _progressTracker.UpdateProgressAsync(...);
    
    // チェックポイントを保存
    await _checkpointManager.SaveCheckpointAsync(...); // ⚠️ この間に失敗したら？
}
```

**影響**:
- バッチ保存は成功したが、チェックポイント保存が失敗した場合、次回は同じデータを再度処理する
- ただし、`SaveOrUpdateProductsBatch`で重複チェックを行っているため、重複登録は発生しない（更新される）

#### 3. 並行実行の問題

**問題**: 同じストアに対して、複数の同期ジョブが同時に実行された場合、重複登録が発生する可能性があります。

**現在の実装** (`SyncController.cs`):
```csharp
// 既に同期中の場合はエラー
var runningSync = await _context.SyncStatuses
    .Where(s => s.StoreId == currentStore.Id && s.Status == "running")
    .FirstOrDefaultAsync();

if (runningSync != null)
{
    return BadRequest(new { error = "Sync already in progress", syncId = runningSync.Id });
}
```

**影響**:
- アプリケーションインスタンスが複数ある場合、このチェックが機能しない可能性がある
- ただし、重複チェックキー（`StoreId` + `Shopify*Id`）があるため、重複登録は発生しない（更新される）

---

## 🏗️ データ同期機能のアーキテクチャ

### 1. アーキテクチャ概要

```
┌─────────────────────────────────────────────────────────────┐
│                    SyncController                            │
│  - StartInitialSync: 初期同期を開始                          │
│  - GetSyncStatus: 同期ステータスを取得                       │
│  - TriggerSync: 手動同期をトリガー                           │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│              ShopifyDataSyncService                          │
│  - StartInitialSync: HangFireジョブとして登録                │
│  - RunInitialSyncWithJobs: 各ジョブクラスを呼び出し          │
└──────────────────────┬──────────────────────────────────────┘
                       │
        ┌──────────────┼──────────────┐
        ▼              ▼              ▼
┌──────────────┐ ┌──────────────┐ ┌──────────────┐
│ProductSyncJob│ │CustomerSyncJob│ │ OrderSyncJob │
│              │ │              │ │              │
│- SyncProducts│ │- SyncCustomers│ │- SyncOrders  │
│- チェックポイント│ │- チェックポイント│ │- チェックポイント│
│- バッチ処理   │ │- バッチ処理   │ │- バッチ処理   │
└──────┬───────┘ └──────┬───────┘ └──────┬───────┘
       │                │                │
       └────────────────┼────────────────┘
                        ▼
            ┌───────────────────────┐
            │   ShopifyApiService    │
            │                        │
            │- FetchProductsPageAsync│
            │- FetchCustomersPageAsync│
            │- FetchOrdersPageAsync  │
            │- UpsertProductAsync    │
            │- UpsertCustomerAsync    │
            │- UpsertOrderAsync      │
            └───────────────────────┘
```

### 2. データフロー

#### 初期同期フロー

```
1. フロントエンド → POST /api/sync/initial
2. SyncController.StartInitialSync
   - SyncStatusを作成（status: "pending"）
   - HangFireジョブとして登録
3. ShopifyDataSyncService.StartInitialSync (HangFireジョブ)
   - SyncStatusを"running"に更新
   - RunInitialSyncWithJobsを呼び出し
4. RunInitialSyncWithJobs
   - 顧客データ同期: CustomerSyncJob.SyncCustomers
   - 商品データ同期: ProductSyncJob.SyncProducts
   - 注文データ同期: OrderSyncJob.SyncOrders
5. 各ジョブクラス
   - ShopifyApiService.Fetch*PageAsync でデータ取得
   - SaveOrUpdate*Batch でバッチ保存
   - チェックポイントを保存
6. 同期完了
   - SyncStatusを"completed"に更新
```

#### 定期同期フロー

```
1. HangFire RecurringJob
   - 各ストアごとに1時間ごと（商品）、2時間ごと（顧客）、3時間ごと（注文）
2. 各ジョブクラス.Sync* を直接呼び出し
   - チェックポイントから再開
   - バッチ処理で保存
   - チェックポイントを更新
```

---

## 📊 重複登録対策の現状

### ✅ 実装済みの対策

1. **重複チェックキー**
   - `StoreId` + `ShopifyCustomerId` (Customers)
   - `StoreId` + `ShopifyProductId` (Products)
   - `StoreId` + `ShopifyOrderId` (Orders)

2. **Upsertパターン**
   - 既存データがあれば更新、なければ新規作成

3. **同期中チェック**
   - `SyncController`で、既に同期中の場合はエラーを返す

4. **チェックポイント管理**
   - 失敗した位置から再開できる

### ⚠️ 改善が必要な点

1. **トランザクション管理**
   - 現在: 各レコードごとに`SaveChangesAsync()`
   - 推奨: バッチ処理で`SaveChangesAsync()`を呼ぶ（新しいジョブクラスでは実装済み）

2. **並行実行制御**
   - 現在: アプリケーションインスタンス内でのチェックのみ
   - 推奨: 分散ロック（Redis等）を使用

3. **エラーハンドリング**
   - 現在: エラー時は例外を再スロー
   - 推奨: 部分的な成功を許容し、エラー詳細を記録

---

## 🔧 推奨される改善策

### 1. トランザクション管理の改善

**現状**: `ShopifyApiService`の`Upsert*Async`メソッドは、各レコードごとに`SaveChangesAsync()`を呼んでいる。

**改善案**: バッチ処理で`SaveChangesAsync()`を呼ぶ（新しいジョブクラスでは既に実装済み）。

```csharp
// 改善後（新しいジョブクラス）
private async Task SaveOrUpdateProductsBatch(int storeId, List<Product> products)
{
    // 既存データを一括取得
    var existingProducts = await _context.Products
        .Where(p => p.StoreId == storeId && shopifyProductIds.Contains(p.ShopifyProductId!))
        .ToDictionaryAsync(p => p.ShopifyProductId!);
    
    foreach (var product in products)
    {
        if (existingProducts.TryGetValue(product.ShopifyProductId, out var existingProduct))
        {
            // 更新
        }
        else
        {
            // 新規作成
            _context.Products.Add(product);
        }
    }
    
    await _context.SaveChangesAsync(); // バッチで一度だけ保存
}
```

### 2. 並行実行制御の改善

**現状**: アプリケーションインスタンス内でのチェックのみ。

**改善案**: 分散ロック（Redis等）を使用して、複数インスタンス間での並行実行を制御。

```csharp
// 改善案（擬似コード）
public async Task StartInitialSync(int storeId, int syncStatusId, string syncPeriod)
{
    // 分散ロックを取得
    var lockKey = $"sync:store:{storeId}";
    var lockAcquired = await _distributedLock.TryAcquireAsync(lockKey, TimeSpan.FromMinutes(30));
    
    if (!lockAcquired)
    {
        _logger.LogWarning("Sync already in progress for store {StoreId}", storeId);
        return;
    }
    
    try
    {
        // 同期処理
    }
    finally
    {
        await _distributedLock.ReleaseAsync(lockKey);
    }
}
```

### 3. エラーハンドリングの改善

**現状**: エラー時は例外を再スロー。

**改善案**: 部分的な成功を許容し、エラー詳細を記録。

```csharp
// 改善案
try
{
    await _orderSyncJob.SyncOrders(store.Id, syncOptions);
}
catch (Exception orderEx)
{
    // Protected Customer Dataエラーの場合、警告を出して続行
    if (IsProtectedCustomerDataError(orderEx))
    {
        _logger.LogWarning("Order sync skipped due to Protected Customer Data");
        // 部分的な成功として処理
    }
    else
    {
        // その他のエラーは再スロー
        throw;
    }
}
```

---

## 📝 ソースコードレビュー結果

### ✅ 良好な点

1. **重複チェックの実装**
   - `StoreId` + `Shopify*Id`で重複チェックを行っている
   - Upsertパターンで更新/新規作成を適切に処理

2. **チェックポイント管理**
   - 失敗した位置から再開できる
   - 進捗トラッキングが実装されている

3. **バッチ処理**
   - 新しいジョブクラスでは、バッチ処理でパフォーマンスを改善

4. **エラーハンドリング**
   - Protected Customer Dataエラーを適切に処理
   - 部分的な成功を許容

### ⚠️ 改善が必要な点

1. **トランザクション管理**
   - `ShopifyApiService`の`Upsert*Async`メソッドは、各レコードごとに`SaveChangesAsync()`を呼んでいる
   - 新しいジョブクラスでは改善されているが、古い実装が残っている

2. **並行実行制御**
   - アプリケーションインスタンス内でのチェックのみ
   - 複数インスタンス間での並行実行を制御する仕組みがない

3. **エラーハンドリング**
   - 一部のエラーは再スローされている
   - 部分的な成功を許容する処理が不十分な箇所がある

---

## 🎯 結論

### 重複登録について

**結論**: **重複登録は発生しません**。

理由:
1. `StoreId` + `Shopify*Id`で重複チェックを行っている
2. Upsertパターンで更新/新規作成を適切に処理
3. 再実行時も、既存データは更新される（重複は発生しない）

### 改善が必要な点

1. **トランザクション管理**: 古い実装（`ShopifyApiService.Upsert*Async`）を新しいジョブクラスのバッチ処理に統一
2. **並行実行制御**: 分散ロックを使用して、複数インスタンス間での並行実行を制御
3. **エラーハンドリング**: 部分的な成功を許容する処理を強化

---

## 📚 関連ドキュメント

- [データ同期機能実装状況レビュー](./データ同期機能実装状況レビュー.md)
- [データ同期-注文データBadRequestエラー対応](../../05-development/08-デバッグ・トラブル/01-problem-analysis/2026-01/2026-01-19-データ同期-注文データBadRequestエラー対応.md)
- [データ同期テスト前のデータクリア手順](../../05-development/08-デバッグ・トラブル/02-tools/データ同期テスト前のデータクリア手順.md)

---

**最終更新**: 2026年1月19日  
**作成者**: AI Assistant
