# アンインストール・再インストールフロー確認結果

## ドキュメント情報

| 項目 | 値 |
|------|-----|
| 確認日 | 2026-01-29 |
| 確認者 | 福田＋AI Assistant |
| 対象 | 同一ストアドメインでのアンインストール→再インストール時の Stores 更新と新規 StoreId 割り当て |

---

## 確認したい流れ

1. **アンインストール時**: Shopify管理画面からアンインストールした際に `Stores` テーブルが更新されるか
2. **再インストール時**: 同じストアドメインで再インストールした場合、**新規ストアID**でインストールされるか

---

## 結論

**はい、想定どおりの流れになっています。**

- アンインストール時に `Stores` の該当行が更新される（Domain の無効化・IsActive=false・AccessToken クリア等）
- 同じドメインで再インストールすると、**既存行はヒットせず新規 Store が作成され、新規 StoreId が割り当てられる**

---

## 根拠（コード上の流れ）

### 1. アンインストール時（WebhookController）

**エンドポイント**: `POST /api/webhook/uninstalled`  
**処理**: `AppUninstalled()` → `CancelStoreSubscription(shopDomain)` → `ScheduleDataDeletion(shopDomain, 48)`

`ScheduleDataDeletion` 内（WebhookController.cs 651–676 行付近）で以下を実施しています。

| 処理 | 内容 |
|------|------|
| ストア検索 | `Stores.FirstOrDefaultAsync(s => s.Domain == shopDomain)` で該当ストアを取得 |
| Settings 保存 | `OriginalDomain`・`UninstalledAt`・`ScheduledDeletionDate` を Settings に保存 |
| 非アクティブ化 | `store.IsActive = false` |
| **Domain の無効化** | `store.Domain = "{元Domain}_uninstalled_{yyyyMMddHHmmss}"` に変更 |
| トークン削除 | `store.AccessToken = null` |
| 保存 | `SaveChangesAsync()` |

ポイントは **「元のドメイン（例: `mystore.myshopify.com`）で検索できる行を残さない」** ように Domain を変更していることです。  
その結果、同じドメインで再インストール時に「既存ストア」としてヒットしなくなります。

---

### 2. 再インストール時（ShopifyAuthController）

**エンドポイント**: `GET /api/shopify/callback`（OAuth コールバック）  
**処理**: `ProcessOAuthSuccessAsync()` → `SaveOrUpdateStore(shopDomain, ...)`

`SaveOrUpdateStore` 内（ShopifyAuthController.Private.cs 502–506 行付近）では次の検索をしています。

```csharp
// 既存のストアを検索（通常のDomainで検索、IsActiveは問わない）
var store = await _context.Stores
    .Include(s => s.ShopifyApp)
    .FirstOrDefaultAsync(s => s.Domain == shopDomain);
```

- コールバックで渡ってくる `shopDomain` は **通常のショップドメイン**（例: `mystore.myshopify.com`）
- アンインストール後は、そのドメインの行は `mystore.myshopify.com_uninstalled_20260129120000` のように変更済みのため、**ここではヒットしない**
- `store == null` となり、**新規 Store 作成**（`_context.Stores.Add(store)`）が実行され、**新規 StoreId** が付与される

コメントにも「再インストール時に既存レコードが見つからないようにする」とある通り、この動きで設計と一致しています。

---

## フロー概要図

```
[アンインストール]
  app/uninstalled Webhook
       ↓
  ScheduleDataDeletion(shopDomain)
       ↓
  Stores: Domain = "mystore.myshopify.com"
          → "mystore.myshopify.com_uninstalled_20260129120000"
  IsActive = false, AccessToken = null, Settings に OriginalDomain 等を保存

[同じドメインで再インストール]
  OAuth callback (shopDomain = "mystore.myshopify.com")
       ↓
  SaveOrUpdateStore(shopDomain)
       ↓
  Stores.FirstOrDefaultAsync(s => s.Domain == "mystore.myshopify.com")
       → ヒットしない（Domain は _uninstalled_ 付きに変更済み）
       ↓
  store == null → 新規 Store 作成 → 新規 StoreId が割り当てられる
```

---

## 補足・注意点

### DataCleanupService の呼び出しタイミング

`ScheduleDataDeletion` 内では、**Domain を `_uninstalled_` に変更したあと**で、開発環境や `daysToDelete == 0` のときに `DeleteStoreDataAsync(shopDomain)` を呼んでいます。

- `DataCleanupService.DeleteStoreDataAsync(domain)` は **`Stores` を `s.Domain == domain` で検索**しています。
- 呼び出し時点では既に `store.Domain` は `xxx_uninstalled_...` に変わっているため、`shopDomain`（元ドメイン）では **ストアがヒットしません**。
- その結果、「即座に削除」や Hangfire でスケジュールした削除ジョブが、**実際にはストアを削除しない**可能性があります。

再インストールで「新規 StoreId になる」という点は、Domain のリネームだけで達成されているため、上記の削除の有無には依存していません。  
データ削除（GDPR 等）を確実に行う必要がある場合は、`DeleteStoreDataAsync` が **OriginalDomain（Settings）や StoreId で検索する**ようにするなどの修正検討が必要です。

---

## 関連ファイル

- `backend/ShopifyAnalyticsApi/Controllers/WebhookController.cs`  
  - `AppUninstalled()`（55行付近）、`ScheduleDataDeletion()`（640行付近）
- `backend/ShopifyAnalyticsApi/Controllers/ShopifyAuthController.Private.cs`  
  - `SaveOrUpdateStore()`（493行付近）
- `docs/03-feature-development/インストールフロー改善機能/インストール機能設計書.md`
