# 同期処理が既に実行中エラー

## 問題の概要

### 発生状況
- **エラーメッセージ**: `API Error: 400 {"error":"Sync already in progress","syncId":2}`
- **原因**: `SyncStatuses`テーブルに`Status = "running"`のレコードが残っている

### エラー発生フロー

1. **初期同期API** (`/api/sync/initial`) が呼び出される
2. `SyncController.StartInitialSync` が実行される
3. `SyncStatuses`テーブルで`Status = "running"`のレコードをチェック（66-68行目）
4. **既に`running`ステータスのレコードが存在する場合、エラーを返す**

## 確認方法

### 1. Hangfireダッシュボードで確認（オプション）

**URL**: `https://ec-ranger-backend-prod-ghf3bbarghcwh4gn.japanwest-01.azurewebsites.net/hangfire`

**注意**: Hangfireダッシュボードにアクセスできない場合があります。その場合は、**方法2（データベースで直接確認）**を使用してください。

**認証**: Basic認証が必要です

**認証情報**:
- **ユーザー名**: 環境変数 `Hangfire__Dashboard__Username` の値（デフォルト: `admin`）
- **パスワード**: 環境変数 `Hangfire__Dashboard__Password` の値（デフォルト: `HangfireAdmin2025!`）

**確認項目**（アクセスできた場合）:
- **Jobs**: 実行中のジョブがあるか
- **Recurring Jobs**: 登録されている定期ジョブ
- **Failed Jobs**: 失敗したジョブがあるか
- **Processing**: 現在処理中のジョブ

**アクセスできない場合の対処**:
- Basic認証ダイアログが表示されない場合、認証フィルターの設定やAzure App Serviceの設定に問題がある可能性があります
- **推奨**: データベースで直接確認する方法（方法2）を使用してください

### 2. データベースで確認（推奨）

**Hangfireダッシュボードにアクセスできない場合でも、データベースで直接確認できます。**

**確認クエリ**:
```sql
-- 実行中の同期ステータスを確認
SELECT 
    Id,
    StoreId,
    SyncType,
    Status,
    StartDate,
    EndDate,
    CurrentTask,
    ProcessedRecords,
    TotalRecords,
    CreatedAt,
    UpdatedAt
FROM SyncStatuses
WHERE Status = 'running'
ORDER BY CreatedAt DESC;
```

**確認項目**:
- `Status = "running"`のレコードが存在するか
- `StartDate`が古すぎないか（例：24時間以上前）
- 実際に同期処理が実行中かどうか

### 3. 同期ステータスの詳細確認

**確認クエリ**:
```sql
-- 特定のsyncIdの詳細を確認
SELECT 
    Id,
    StoreId,
    SyncType,
    Status,
    StartDate,
    EndDate,
    CurrentTask,
    ProcessedRecords,
    TotalRecords,
    ErrorMessage,
    CreatedAt,
    UpdatedAt
FROM SyncStatuses
WHERE Id = 2;  -- エラーメッセージのsyncId
```

## 解決方法

### 方法1: 特定のsyncIdをクリア（推奨）

**条件**: 実際に同期処理が実行中でない場合（Hangfireダッシュボードで確認）

**マイグレーションスクリプト**: `2025-12-25-FIX-ClearStuckSyncStatus.sql`

**SQLスクリプト**:
```sql
-- Id=2のレコードをfailedに変更
UPDATE SyncStatuses
SET 
    Status = 'failed',
    EndDate = GETUTCDATE(),
    ErrorMessage = 'Manually cleared: Sync was stuck in running state. Hangfire job may have been lost.',
    UpdatedAt = GETUTCDATE()
WHERE Id = 2
    AND Status = 'running';
```

**確認クエリ**:
```sql
SELECT 
    Id,
    StoreId,
    SyncType,
    Status,
    StartDate,
    EndDate,
    ErrorMessage,
    UpdatedAt
FROM SyncStatuses
WHERE Id = 2;
```

### 方法2: 24時間以上前のrunningステータスをすべてクリア

**SQLスクリプト**:
```sql
-- 24時間以上前のrunningステータスをfailedに変更
UPDATE SyncStatuses
SET 
    Status = 'failed',
    EndDate = GETUTCDATE(),
    ErrorMessage = 'Manually cleared: Sync was stuck in running state for more than 24 hours.',
    UpdatedAt = GETUTCDATE()
WHERE Status = 'running'
    AND StartDate < DATEADD(HOUR, -24, GETUTCDATE());
```

### 方法3: Hangfireジョブをキャンセル

**条件**: Hangfireダッシュボードで実行中のジョブが確認できる場合

**手順**:
1. Hangfireダッシュボードにアクセス
2. 「Jobs」タブで該当するジョブを探す
3. ジョブをキャンセル
4. データベースで`SyncStatuses`のステータスを更新（方法1を実行）

### 方法4: すべての同期ステータスをリセット（緊急時のみ）

**条件**: すべての同期処理をリセットしたい場合

**SQLスクリプト**:
```sql
-- すべてのrunningステータスをfailedに変更
UPDATE SyncStatuses
SET 
    Status = 'failed',
    EndDate = GETUTCDATE(),
    ErrorMessage = 'Manually reset: All syncs were reset',
    UpdatedAt = GETUTCDATE()
WHERE Status = 'running';
```

## 予防策

### 1. タイムアウト処理の実装

同期処理が長時間実行されている場合、自動的にタイムアウトとして扱う処理を追加する。

### 2. 定期的なクリーンアップジョブ

古い`running`ステータスを定期的にクリーンアップするHangfireジョブを登録する。

### 3. 同期ステータスの監視

アプリケーション起動時に、古い`running`ステータスがないかチェックし、自動的にクリアする。

## 関連ファイル

- `backend/ShopifyAnalyticsApi/Controllers/SyncController.cs` - 同期コントローラー
- `backend/ShopifyAnalyticsApi/Services/ShopifyDataSyncService.cs` - 同期サービス
- `backend/ShopifyAnalyticsApi/Models/SyncStatus.cs` - 同期ステータスエンティティ

## 更新履歴

- 2025-12-25: 初版作成（福田 + AI Assistant）
