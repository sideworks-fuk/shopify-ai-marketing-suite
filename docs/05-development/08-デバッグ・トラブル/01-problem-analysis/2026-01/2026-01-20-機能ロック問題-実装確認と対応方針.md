# 機能ロック問題 - 実装確認と対応方針

## 📋 問題概要

有料プランに設定されているにもかかわらず、「この機能は現在ロックされています」という表示が表示されてしまう問題。

**発生画面**: `/purchase/count-analysis`（購入回数分析【購買】）

## 🔍 実装確認結果

### 1. フロントエンドの機能ロック判定ロジック

**ファイル**: `frontend/src/hooks/useFeatureAccess.ts`

#### 問題点

```typescript:203:248:frontend/src/hooks/useFeatureAccess.ts
export function useFeatureAccess(featureId?: SelectableFeatureId) {
  const { currentPlan } = useSubscriptionContext();
  const [isLoading, setIsLoading] = useState(true);
  const [hasAccess, setHasAccess] = useState(false);
  
  const currentPlanId = (currentPlan?.id as PlanId) || 'starter'; // ⚠️ デフォルトは'starter'（無料プラン）
  const gateDisabled = process.env.NEXT_PUBLIC_DISABLE_FEATURE_GATES === 'true';

  useEffect(() => {
    const checkAccess = async () => {
      setIsLoading(true);
      // 環境フラグで機能ゲートを一時無効化
      if (gateDisabled) {
        setHasAccess(true);
        setIsLoading(false);
        return;
      }
      
      // If user has a paid plan, they have access to all features
      if (currentPlanId && currentPlanId !== 'starter') {
        setHasAccess(true);
        setIsLoading(false);
        return;
      }

      // For free plan users, only allow access to dormant_analysis
      // 無料プランは「休眠顧客分析」のみ利用可能
      if (currentPlanId === 'starter') {
        setHasAccess(featureId === 'dormant_analysis'); // ⚠️ frequency_detailはアクセス不可
      } else {
        setHasAccess(false);
      }
      
      setIsLoading(false);
    };

    checkAccess();
  }, [currentPlanId, featureId, gateDisabled]);
```

**問題点**:
1. **デフォルトが無料プラン**: `currentPlan`が`null`または`undefined`の場合、デフォルトで`'starter'`（無料プラン）として扱われる
2. **無料プランでは`dormant_analysis`のみ**: `frequency_detail`（購入回数分析）は無料プランではアクセス不可
3. **プラン情報の取得タイミング**: `SubscriptionContext`がプラン情報を取得する前に、ロック判定が実行される可能性がある

### 2. バックエンドの機能アクセス制御

**ファイル**: `backend/ShopifyAnalyticsApi/Middleware/FeatureAccessMiddleware.cs`

#### 実装内容

```csharp:206:214:backend/ShopifyAnalyticsApi/Middleware/FeatureAccessMiddleware.cs
private bool CheckFeatureAccess(FeatureAccessInfo accessInfo, string requestedFeature)
{
    // 有料プランは全機能アクセス可能
    if (accessInfo.IsPaidPlan)
        return true;

    // 無料プランは選択された機能のみアクセス可能
    return accessInfo.SelectedFeatures.Contains(requestedFeature);
}
```

**バックエンドの判定ロジック**:
- ✅ 有料プラン（`Status = "active"`または`Status = "trialing"`）: 全機能アクセス可能
- ✅ 無料プラン: 選択された機能のみアクセス可能

**問題点**:
- フロントエンドで先にロックされてしまうため、バックエンドの判定まで到達しない

### 3. プラン情報の取得

**ファイル**: `frontend/src/contexts/SubscriptionContext.tsx`

#### 実装内容

```typescript:184:233:frontend/src/contexts/SubscriptionContext.tsx
const fetchSubscriptionData = useCallback(async () => {
  try {
    setLoading(true);
    setError(null);

    const apiClient = getApiClient();
    
    // Fetch current subscription
    try {
      const subData = await apiClient.get<{ subscription: Subscription | null }>('/api/subscription/status');
      setSubscription(subData.subscription || null);
    } catch (subErr: any) {
      // 404エラーの場合はサブスクリプションなしとして扱う
      if (subErr?.message?.includes('404') || subErr?.message?.includes('Not Found')) {
        setSubscription(null);
      } else {
        throw subErr;
      }
    }

    // Fetch available plans
    try {
      const plansData = await apiClient.get<{ plans: BillingPlan[] }>('/api/subscription/plans');
      if (plansData.plans && Array.isArray(plansData.plans)) {
        setPlans(plansData.plans);
      }
    } catch (plansErr) {
      console.warn('Failed to fetch plans, using mock plans:', plansErr);
      // プラン取得に失敗してもモックプランを使用して続行
    }
  } catch (err) {
    console.error('Error fetching subscription data:', err);
    setError(err instanceof Error ? err.message : 'Unknown error occurred');
    
    // Use mock data in development
    if (process.env.NODE_ENV === 'development' && !process.env.NEXT_PUBLIC_API_URL) {
      setSubscription({
        id: 'sub_mock',
        planId: 'starter',
        status: 'trialing',
        currentPeriodStart: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),
        currentPeriodEnd: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
        trialEnd: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
      });
    }
  } finally {
    setLoading(false);
  }
}, [getApiClient]);
```

**問題点**:
1. **API呼び出しのタイミング**: `useEffect`内で非同期に呼び出されるため、初回レンダリング時には`currentPlan`が`null`の可能性がある
2. **デフォルト値**: プラン情報が取得できない場合、`currentPlan`は`null`になり、`useFeatureAccess`では`'starter'`として扱われる

### 4. 機能IDの不一致

**フロントエンド**: `frequency_detail`（`SelectableFeatureId`型）
**バックエンド**: `purchase_frequency`（`FeatureConstants.PurchaseFrequency`）

**確認**:
- `frontend/src/app/purchase/count-analysis/page.tsx`: `useFeatureAccess('frequency_detail')`
- `backend/ShopifyAnalyticsApi/Models/FeatureSelectionModels.cs`: `FeatureConstants.PurchaseFrequency = "purchase_frequency"`

**問題点**:
- フロントエンドとバックエンドで機能IDが一致していない可能性がある

## ✅ 対応方針

### 方針1: デフォルトをロック解除にする（推奨・一時的対応）

**目的**: 開発・テスト期間中は機能ロックを無効化

**実装方法**:
1. 環境変数`NEXT_PUBLIC_DISABLE_FEATURE_GATES`を`true`に設定
2. フロントエンドの`.env.local`または`.env.production`に追加

**メリット**:
- 即座に問題を解決できる
- 開発・テスト期間中は全機能が利用可能

**デメリット**:
- 本番環境でも機能ロックが無効になる（本番環境では`false`に設定する必要がある）

### 方針2: プラン情報の取得を待つ（推奨・恒久的対応）

**目的**: プラン情報が取得されるまで、ロック判定を待機

**実装方法**:
1. `useFeatureAccess`フックで、`SubscriptionContext`の`loading`状態を確認
2. `loading === true`の間は、ロック判定をスキップ（または`hasAccess = true`として扱う）
3. プラン情報が取得された後に、正しいロック判定を実行

**メリット**:
- プラン情報が正しく取得された後に判定されるため、誤ったロックが発生しない
- 恒久的な解決策

**デメリット**:
- 実装が複雑になる可能性がある

### 方針3: デフォルトを有料プランとして扱う（検討）

**目的**: プラン情報が取得できない場合、一時的に有料プランとして扱う

**実装方法**:
1. `useFeatureAccess`フックで、`currentPlan`が`null`の場合、一時的に有料プランとして扱う
2. プラン情報が取得された後に、正しい判定を実行

**メリット**:
- 誤ったロックを防げる

**デメリット**:
- プラン情報が取得できない場合、全機能が利用可能になってしまう（セキュリティリスク）

## ✅ 実装済みの対応

### 対応内容1: プラン情報取得中はデフォルトでロック解除（修正済み）

**実装日**: 2026-01-20（初回）  
**修正日**: 2026-01-20（無限ローディング問題の修正）

**修正ファイル**: `frontend/src/hooks/useFeatureAccess.ts`

**初回実装内容**:
- `SubscriptionContext`の`loading`状態を確認
- プラン情報の取得中（`subscriptionLoading === true`）は、一時的に`hasAccess = true`として扱う
- プラン情報が取得された後に、正しいロック判定を実行

**問題点**:
- `subscriptionLoading === true`の間、`isLoading = true`のままにしていたため、認証エラーなどでプラン情報の取得が失敗した場合、無限にローディング状態が続く問題が発生

**修正内容**:
- `subscriptionLoading === true`の間でも、`isLoading = false`にして画面を表示可能にする
- これにより、認証エラーなどでプラン情報の取得が失敗した場合でも、機能を使えるようになる

**メリット**:
- プラン情報が取得されるまでの間、誤ったロックが発生しない
- 認証エラーなどでプラン情報の取得が失敗した場合でも、画面が表示される
- プラン情報が取得された後は、正しい判定が行われる

**注意点**:
- プラン情報の取得に失敗した場合、デフォルトでロック解除になる（セキュリティリスクの可能性）
- 本番環境では、プラン情報の取得が確実に行われることを確認する必要がある

### 対応内容2: 認証エラー（401）の調査

**問題**: `GET https://ec-ranger-api.access-net.co.jp/api/store 401 (Unauthorized)`

**原因の可能性**:
1. Shopify埋め込みアプリモードで、セッショントークンが正しく送信されていない
2. `X-Store-Id`ヘッダーが設定されていない
3. JWTトークンに`store_id`クレームが含まれていない

**確認事項**:
- `AuthProvider`でセッショントークンが正しく取得できているか
- `StoreContextMiddleware`で`store_id`が正しく取得できているか
- `/api/store`エンドポイントの認証要件

**次のステップ**:
- 認証フローの詳細な調査が必要
- ただし、ローディング問題は修正済みのため、画面は表示されるようになる

## 🔧 追加の対応（必要に応じて）

### オプション1: 環境変数で機能ゲートを無効化

**目的**: 開発・テスト期間中は機能ロックを完全に無効化

**実装方法**:
1. 環境変数`NEXT_PUBLIC_DISABLE_FEATURE_GATES`を`true`に設定
2. フロントエンドの`.env.local`または`.env.production`に追加

**注意**: 本番環境では`false`に設定する必要がある

### オプション2: 機能IDの統一

**目的**: フロントエンドとバックエンドで機能IDを統一

**確認事項**:
- フロントエンド: `frequency_detail`（`SelectableFeatureId`型）
- バックエンド: `purchase_frequency`（`FeatureConstants.PurchaseFrequency`）

**対応方法**:
- 機能IDの対応関係を明確化
- 必要に応じて、フロントエンドまたはバックエンドの機能IDを統一

## 📝 確認事項

### 現在の状態

- [ ] `NEXT_PUBLIC_DISABLE_FEATURE_GATES`の設定値
- [ ] `SubscriptionContext`の`loading`状態
- [ ] `currentPlan`の値（ブラウザの開発者ツールで確認）
- [ ] バックエンドの`StoreSubscriptions`テーブルの状態

### デバッグ方法

1. **ブラウザの開発者ツールで確認**
   ```javascript
   // React DevToolsで確認
   // SubscriptionContextのcurrentPlanの値
   // useFeatureAccessのhasAccessの値
   ```

2. **ネットワークタブで確認**
   - `/api/subscription/status`のレスポンス
   - `/api/subscription/plans`のレスポンス

3. **バックエンドログで確認**
   - `FeatureAccessMiddleware`のログ
   - `StoreSubscriptions`テーブルの状態

## 🔗 関連ファイル

- `frontend/src/hooks/useFeatureAccess.ts`
- `frontend/src/contexts/SubscriptionContext.tsx`
- `frontend/src/app/purchase/count-analysis/page.tsx`
- `backend/ShopifyAnalyticsApi/Middleware/FeatureAccessMiddleware.cs`
- `backend/ShopifyAnalyticsApi/Services/FeatureSelectionService.cs`

---

**作成日**: 2026-01-20  
**作成者**: AI Assistant
