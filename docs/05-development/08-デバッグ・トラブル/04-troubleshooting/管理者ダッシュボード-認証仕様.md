# 管理者ダッシュボード - 認証仕様

## 📋 概要

管理者ダッシュボード（`/admin`）、Swagger UI（`/swagger`）、HangFireダッシュボード（`/hangfire`）は、**共通のBasic認証**で保護されています。

一度認証に成功すると、8時間有効なセッションCookie（`admin_auth_session`）が設定され、同じブラウザセッション内では再認証不要でアクセスできます。

---

## 🔐 認証方式

### 認証タイプ
- **Basic認証**（HTTP Basic Authentication）
- **セッションCookie**（認証成功後、8時間有効）

### 認証フロー

```
1. クライアントが /admin, /swagger, /hangfire のいずれかにアクセス
   ↓
2. AdminBasicAuthMiddleware が実行される
   ↓
3. セッションCookie（admin_auth_session）をチェック
   - 有効なCookieがあれば → 認証成功、次のミドルウェアへ
   ↓
4. Cookieがない場合、Authorizationヘッダーをチェック
   - Basic認証ヘッダーがあれば → 認証情報を検証
   ↓
5. 認証成功 → セッションCookieを設定、次のミドルウェアへ
   認証失敗 → 401 Unauthorized を返す
```

---

## 🔑 Basic認証の設定方法

### 方法1: 環境変数（推奨・本番環境）

**Azure App Serviceの場合**:
1. Azure Portal → App Service → 構成 → アプリケーション設定
2. 「+ 新しいアプリケーション設定」をクリック
3. 以下を設定：
   - **名前**: `Admin__BasicAuth__Username`
   - **値**: `admin`（または任意のユーザー名）
   - **名前**: `Admin__BasicAuth__Password`
   - **値**: `your-secure-password-here`（強力なランダム文字列）

**PowerShellの場合**:
```powershell
az webapp config appsettings set `
  --resource-group ec-ranger-prod `
  --name ec-ranger-backend-prod `
  --settings Admin__BasicAuth__Username="admin" Admin__BasicAuth__Password="your-secure-password-here"
```

### 方法2: appsettings.json（開発環境のみ）

**⚠️ 注意**: 本番環境では使用しないでください

`appsettings.json`または`appsettings.Development.json`に追加：

```json
{
  "Admin": {
    "BasicAuth": {
      "Username": "admin",
      "Password": "your-secure-password-here",
      "SkipInDevelopment": false
    }
  }
}
```

### 設定の優先順位

認証情報は以下の優先順位で取得されます：

1. **`Admin:BasicAuth:Username`** / **`Admin:BasicAuth:Password`**（最優先）
2. `Swagger:BasicAuth:Username` / `Swagger:BasicAuth:Password`
3. `Hangfire:Dashboard:Username` / `Hangfire:Dashboard:Password`
4. デフォルト値（`admin` / `Admin2025!`）

---

## 📝 認証の実装詳細

### コード実装

**ファイル**: `backend/ShopifyAnalyticsApi/Middleware/AdminBasicAuthMiddleware.cs`

```csharp
public async Task InvokeAsync(HttpContext context)
{
    var path = context.Request.Path.Value?.ToLower() ?? "";
    
    // 対象パスをチェック
    var targetPaths = new[] { "/admin", "/swagger", "/hangfire" };
    var isTargetPath = targetPaths.Any(targetPath => path.StartsWith(targetPath));

    if (!isTargetPath)
    {
        await _next(context);
        return;
    }

    // セッションCookieをチェック（既に認証済みの場合）
    if (context.Request.Cookies[AdminAuthCookieName] == AdminAuthCookieValue)
    {
        await _next(context);
        return;
    }

    // Basic認証のチェック
    var authHeader = context.Request.Headers["Authorization"].ToString();
    if (!string.IsNullOrEmpty(authHeader) && authHeader.StartsWith("Basic "))
    {
        // 認証情報を検証
        // 成功したらセッションCookieを設定
    }
}
```

### 認証チェック箇所

1. **`/admin`** - 管理者ダッシュボード（HTML）
2. **`/admin/info`** - 管理者ダッシュボード（JSON API）
3. **`/swagger`** - Swagger UI
4. **`/hangfire`** - HangFireダッシュボード（`HangfireAuthorizationFilter`でもチェック）

### セッションCookie

- **Cookie名**: `admin_auth_session`
- **Cookie値**: `authenticated`
- **有効期限**: 8時間
- **属性**:
  - `HttpOnly`: true（JavaScriptからアクセス不可）
  - `Secure`: true（HTTPS必須）
  - `SameSite`: Lax

---

## 🚫 認証失敗時のレスポンス

### ステータスコード
- **401 Unauthorized**

### レスポンスヘッダー
```
WWW-Authenticate: Basic realm="EC Ranger Admin"
```

### レスポンスボディ

**HTMLエンドポイント（/admin）**:
```
Unauthorized
```

**JSONエンドポイント（/admin/info）**:
```json
{
  "error": "Unauthorized",
  "message": "管理者認証が必要です"
}
```

---

## ✅ 認証成功時の動作

### 認証成功後

1. **セッションCookieの設定**: `admin_auth_session=authenticated`（8時間有効）
2. **リクエストの継続**: 次のミドルウェアへ処理を渡す
3. **再認証不要**: 同じブラウザセッション内では再認証不要

### HangFireダッシュボードの場合

`HangfireAuthorizationFilter`でも以下の順序で認証をチェックします：

1. **セッションCookie**（`admin_auth_session`）をチェック（優先）
2. ローカルアクセス（127.0.0.1）を許可
3. 認証済みユーザー（JWT/OAuth）をチェック
4. Basic認証ヘッダーをチェック（フォールバック）

---

## 🔒 セキュリティ考慮事項

### 現在の実装の特徴

| 項目 | 説明 |
|------|------|
| **認証方式** | HTTP Basic認証 |
| **認証情報送信** | `Authorization: Basic {base64(username:password)}`ヘッダー |
| **セッション管理** | Cookieベース（8時間有効） |
| **暗号化** | HTTPS必須（`Secure`フラグ） |
| **有効期限** | 8時間（Cookie） |
| **レート制限** | なし（将来的に追加予定） |

### セキュリティ上の注意点

1. **HTTPS必須**: 
   - Cookieの`Secure`フラグが有効なため、HTTPS接続が必須
   - HTTPではCookieが設定されない

2. **強力なパスワードを使用**: 
   - 推奨: 32文字以上のランダム文字列
   - 例: `openssl rand -hex 32` で生成

3. **パスワードの管理**:
   - 環境変数で管理（本番環境）
   - Gitにコミットしない（`.gitignore`に追加）
   - 定期的にローテーション

4. **アクセスログの監視**:
   - 認証失敗のログを監視
   - 異常なアクセスパターンを検知

5. **セッションCookieの保護**:
   - `HttpOnly`フラグにより、XSS攻撃から保護
   - `SameSite=Lax`により、CSRF攻撃を軽減

---

## 🔄 認証ミドルウェアとの関係

### 認証のスキップ

`AdminController`は**認証ミドルウェアの前にマッピング**されているため、通常のJWT認証やShopify OAuth認証をスキップします。

**Program.cs**:
```csharp
// 管理者向けBasic認証ミドルウェア（最初に配置）
app.UseAdminBasicAuth();

// Swagger設定
app.UseSwagger();
app.UseSwaggerUI(...);

// HangFireダッシュボード設定
app.UseHangfireDashboard("/hangfire", new Hangfire.DashboardOptions
{
    Authorization = new[] { new HangfireAuthorizationFilter() },
    ...
});

// 管理者向けエンドポイントを認証前にマッピング
app.MapControllerRoute(
    name: "admin",
    pattern: "admin/{action=Index}",
    defaults: new { controller = "Admin" });

// その他の認証ミドルウェア...
app.UseAuthModeMiddleware();
app.UseAuthentication();
app.UseAuthorization();
```

### 認証フロー図

```
リクエスト: /admin, /swagger, /hangfire
    ↓
[AdminBasicAuthMiddleware]
    ↓
セッションCookieチェック
    ↓
[有効なCookie] → 認証成功、次のミドルウェアへ
    ↓
[無効/なし] → Basic認証ヘッダーチェック
    ↓
[認証成功] → セッションCookie設定、次のミドルウェアへ
[認証失敗] → 401 Unauthorized
```

---

## 📊 他の認証方式との比較

| 認証方式 | 管理者ダッシュボード | Swagger UI | HangFire | 通常のAPI |
|---------|-------------------|-----------|----------|----------|
| **認証タイプ** | Basic認証 + Cookie | Basic認証 + Cookie | Basic認証 + Cookie | JWT / Shopify OAuth |
| **認証位置** | AdminBasicAuthMiddleware | AdminBasicAuthMiddleware | HangfireAuthorizationFilter | AuthModeMiddleware |
| **設定場所** | Admin:BasicAuth | Admin:BasicAuth | Admin:BasicAuth | JWT設定 / Shopify設定 |
| **有効期限** | 8時間（Cookie） | 8時間（Cookie） | 8時間（Cookie） | JWT: 60分 |

---

## 🛠️ トラブルシューティング

### 問題1: Basic認証ダイアログが表示されない

**原因**: ブラウザが既に認証済み、またはセッションCookieが有効

**確認方法**:
1. ブラウザの開発者ツールでCookieを確認（`admin_auth_session`）
2. Cookieを削除して再アクセス

**解決方法**:
```javascript
// ブラウザの開発者ツール（Console）で実行
document.cookie = "admin_auth_session=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
```

### 問題2: 認証が常に失敗する

**原因**: 認証情報が設定されていない、または不一致

**確認方法**:
1. Azure Portalで環境変数`Admin__BasicAuth__Username`と`Admin__BasicAuth__Password`が設定されているか確認
2. `appsettings.json`に`Admin:BasicAuth:Username`と`Admin:BasicAuth:Password`が設定されているか確認
3. ユーザー名とパスワードが正しいか確認

**解決方法**:
```powershell
# 環境変数を確認
az webapp config appsettings list `
  --resource-group ec-ranger-prod `
  --name ec-ranger-backend-prod `
  --query "[?name=='Admin__BasicAuth__Username' || name=='Admin__BasicAuth__Password']"
```

### 問題3: 認証が成功するが、HangFireにアクセスできない

**原因**: `HangfireAuthorizationFilter`の認証チェックが失敗している

**確認方法**:
1. セッションCookie（`admin_auth_session`）が設定されているか確認
2. `HangfireAuthorizationFilter`のログを確認

**解決方法**:
- セッションCookieが設定されていれば、HangFireでも自動的に認証成功するはずです
- 問題が続く場合は、`HangfireAuthorizationFilter`の実装を確認

### 問題4: 開発環境で認証がスキップされない

**原因**: `SkipInDevelopment`設定が`false`になっている

**確認方法**:
```json
{
  "Admin": {
    "BasicAuth": {
      "SkipInDevelopment": true  // 開発環境で認証をスキップ
    }
  }
}
```

---

## 🔮 今後の改善予定

### セキュリティ強化

- [ ] **レート制限**: 認証失敗回数に応じたIP制限
- [ ] **ログ記録**: 認証成功/失敗のログを記録
- [ ] **パスワードローテーション**: 定期的なパスワード変更機能
- [ ] **セッション管理**: セッションタイムアウト機能の強化

### 認証方式の改善

- [ ] **JWT認証**: より安全なJWTベースの認証（オプション）
- [ ] **多要素認証**: 追加の認証要素
- [ ] **IP制限**: 特定のIPアドレスからのみアクセス可能にする

---

## 📚 関連ドキュメント

- [管理者ダッシュボード使用方法](./管理者ダッシュボード使用方法.md)
- [HangFire設定ガイド](../04-Azure_DevOps/HangFire設定ガイド.md)
- [認証・セキュリティ設定](../09-認証・セキュリティ/)
