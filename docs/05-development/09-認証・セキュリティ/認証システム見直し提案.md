# 認証システム見直し提案

**作成日**: 2025-01-22  
**作成者**: AI Assistant  
**対象**: 開発チーム

## 1. 現状の問題点

### 1.1 複雑な認証フロー

現在、以下の4つの認証方式が混在しています：

1. **Shopify埋め込みアプリ**: App Bridgeセッショントークン（Authorizationヘッダー）
2. **スタンドアロンOAuth**: Cookieベース認証（`oauth_session` Cookie）
3. **デモモード**: デモトークン（Authorizationヘッダー）
4. **開発者モード**: 開発者トークン（Authorizationヘッダー）

### 1.2 Cookieベース認証の問題

- **401エラーが頻発**: Cookieが正しく送信・読み取れていない
- **CORS設定の複雑さ**: `SameSite` 設定が環境によって異なる
- **デバッグの困難さ**: Cookieの送信状況を確認しにくい
- **クロスオリジン対応**: ngrok等の開発環境で問題が発生しやすい

### 1.3 認証状態管理の複雑さ

- **フロントエンド**: `localStorage` + Cookieの二重管理
- **バックエンド**: Cookie + Authorizationヘッダーの二重チェック
- **状態の不整合**: フロントエンドとバックエンドで認証状態が一致しない

### 1.4 コードの複雑さ

- **AuthModeMiddleware**: 複数の認証方式を1つのミドルウェアで処理
- **ApiClient**: 認証方式によって異なるヘッダーを送信
- **AuthProvider**: 認証方式によって異なる初期化ロジック

## 2. 改善提案

### 2.1 JWTトークンベースの統一認証（推奨）

#### 提案内容

**すべての認証方式をJWTトークンに統一**

1. **OAuth認証成功後**: JWTトークンを生成してCookieとレスポンスの両方に含める
2. **フロントエンド**: JWTトークンを`localStorage`に保存し、Authorizationヘッダーで送信
3. **バックエンド**: AuthorizationヘッダーまたはCookieからJWTトークンを読み取り、検証

#### メリット

- ✅ **統一された認証方式**: すべての認証方式がJWTトークンを使用
- ✅ **デバッグが容易**: トークンの内容を確認できる
- ✅ **セキュリティ向上**: トークンに有効期限を設定可能
- ✅ **スケーラビリティ**: ステートレスな認証（Redis不要）
- ✅ **CORS問題の解消**: Cookieに依存しない

#### 実装方針

```csharp
// OAuth認証成功後
var jwtToken = _tokenService.GenerateAccessToken(storeId, shop);
var refreshToken = _tokenService.GenerateRefreshToken(storeId);

// Cookieとレスポンスの両方に含める（互換性のため）
Response.Cookies.Append("auth_token", jwtToken, cookieOptions);
return Ok(new { 
    accessToken = jwtToken, 
    refreshToken = refreshToken,
    storeId = storeId 
});
```

```typescript
// フロントエンド
const { accessToken } = await response.json();
localStorage.setItem('auth_token', accessToken);

// APIリクエスト時
headers: {
  'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
}
```

### 2.2 段階的移行アプローチ（現実的）

#### Phase 1: JWTトークンの追加（既存Cookieと併用）

- OAuth認証成功後、JWTトークンとCookieの両方を設定
- バックエンドは両方をサポート（優先順位: JWT > Cookie）
- フロントエンドはJWTトークンを優先使用

#### Phase 2: Cookieベース認証の段階的廃止

- フロントエンドをJWTトークンに完全移行
- バックエンドのCookieチェックを削除
- デバッグとテストを実施

#### Phase 3: 認証フローの簡素化

- `AuthModeMiddleware`の簡素化
- `ApiClient`の簡素化
- 不要なコードの削除

### 2.3 代替案: Cookieベース認証の改善（最小限の変更）

#### 提案内容

現在のCookieベース認証を改善し、問題を解決

1. **Cookie設定の統一**: 環境に関係なく一貫した設定
2. **デバッグログの強化**: Cookieの送信・読み取り状況を詳細に記録
3. **CORS設定の見直し**: Cookie送信に必要な設定を確認

#### メリット

- ✅ **変更が最小限**: 既存のコードを大きく変更しない
- ✅ **迅速な対応**: すぐに実装可能

#### デメリット

- ❌ **根本的な解決にならない**: Cookieの問題は残る可能性がある
- ❌ **複雑さが残る**: 認証方式の混在は継続

## 3. 推奨アプローチ

### 3.1 短期対応（即座に実施）

1. **Cookie設定の修正**: 開発環境での動作を確認
2. **デバッグログの追加**: Cookieの送信・読み取り状況を記録
3. **エラーハンドリングの改善**: 401エラー時の詳細情報を出力

### 3.2 中期対応（1-2週間）

1. **JWTトークンの追加**: OAuth認証成功後にJWTトークンを生成
2. **フロントエンドの移行**: JWTトークンを優先使用
3. **バックエンドの両対応**: JWTとCookieの両方をサポート

### 3.3 長期対応（1ヶ月）

1. **Cookieベース認証の廃止**: JWTトークンに完全移行
2. **認証フローの簡素化**: 不要なコードの削除
3. **ドキュメントの更新**: 新しい認証フローの文書化

## 4. 実装例

### 4.1 OAuth認証成功後のJWTトークン生成

```csharp
// ShopifyAuthController.cs
var storeId = await SaveOrUpdateStore(shop, accessToken, ...);

// JWTトークンを生成
var tokenService = HttpContext.RequestServices.GetRequiredService<ITokenService>();
var jwtToken = tokenService.GenerateAccessToken(storeId, shop);
var refreshToken = tokenService.GenerateRefreshToken(storeId);

// Cookieに設定（互換性のため）
var cookieOptions = new CookieOptions
{
    HttpOnly = true,
    Secure = !isDevelopment,
    SameSite = isDevelopment ? SameSiteMode.Lax : SameSiteMode.None,
    Expires = DateTimeOffset.UtcNow.AddDays(7),
    Path = "/"
};
Response.Cookies.Append("auth_token", jwtToken, cookieOptions);

// レスポンスにも含める（フロントエンドでlocalStorageに保存）
var redirectUrl = $"{appUrl}/auth/success?shop={shop}&storeId={storeId}&token={jwtToken}&success=true";
return Redirect(redirectUrl);
```

### 4.2 フロントエンドでのJWTトークン使用

```typescript
// auth/success/page.tsx
const token = searchParams?.get('token');
if (token) {
  localStorage.setItem('auth_token', token);
  localStorage.setItem('oauth_authenticated', 'true');
}

// api-client.ts
private async getAuthHeaders(): Promise<HeadersInit> {
  // JWTトークンを優先使用
  const jwtToken = typeof window !== 'undefined' 
    ? localStorage.getItem('auth_token') 
    : null;
  
  if (jwtToken) {
    return {
      'Authorization': `Bearer ${jwtToken}`
    };
  }
  
  // フォールバック: Shopify埋め込みアプリのセッショントークン
  if (this.options.getShopifyToken) {
    const token = await this.options.getShopifyToken();
    return {
      'Authorization': `Bearer ${token}`
    };
  }
  
  return {};
}
```

### 4.3 バックエンドでのJWTトークン検証

```csharp
// AuthModeMiddleware.cs
// AuthorizationヘッダーからJWTトークンを取得
var authHeader = context.Request.Headers["Authorization"].FirstOrDefault();
string? token = null;

if (!string.IsNullOrEmpty(authHeader) && authHeader.StartsWith("Bearer "))
{
    token = authHeader.Substring("Bearer ".Length).Trim();
}

// JWTトークンを検証
if (!string.IsNullOrEmpty(token))
{
    var tokenService = context.RequestServices.GetRequiredService<ITokenService>();
    var validationResult = tokenService.ValidateToken(token);
    
    if (validationResult.IsValid)
    {
        authResult = new AuthenticationResult
        {
            IsValid = true,
            StoreId = validationResult.StoreId,
            ShopDomain = validationResult.ShopDomain,
            AuthMode = "JWT"
        };
    }
}
```

## 5. 結論

### 推奨: JWTトークンベースの統一認証

**理由:**
1. **長期的な保守性**: 統一された認証方式でコードが簡潔になる
2. **セキュリティ向上**: トークンに有効期限を設定可能
3. **デバッグの容易さ**: トークンの内容を確認できる
4. **CORS問題の解消**: Cookieに依存しない

**段階的移行:**
- 短期: Cookie設定の修正とデバッグログの追加
- 中期: JWTトークンの追加とフロントエンドの移行
- 長期: Cookieベース認証の廃止とコードの簡素化

### 代替案: Cookieベース認証の改善

**適用条件:**
- 時間的制約がある場合
- 最小限の変更で問題を解決したい場合

**注意点:**
- 根本的な解決にならない可能性がある
- 将来的にJWTトークンへの移行が必要になる可能性がある

## 6. 次のステップ

1. **意思決定**: JWTトークンベースの統一認証に移行するか、Cookieベース認証を改善するか
2. **実装計画**: 選択したアプローチに基づいて実装計画を立案
3. **段階的実装**: 短期・中期・長期の計画に基づいて実装

---

**最終更新**: 2025-01-22  
**次回レビュー**: 実装開始前

