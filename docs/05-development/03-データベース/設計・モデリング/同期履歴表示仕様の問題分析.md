# 同期履歴表示仕様の問題分析

## 問題の概要

- **初期同期実行中**: 表示される ✅
- **手動同期実行中**: 表示されない ❌

## 原因分析

### 1. Status設定の違い

#### 初期同期
```csharp
// SyncController.cs - StartInitialSync
var syncStatus = new SyncStatus
{
    Status = "pending",  // 最初は"pending"
    // ...
};

// ShopifyDataSyncService.cs - StartInitialSync
syncStatus.Status = "running";  // Hangfireジョブ開始時に"running"に更新
```

#### 手動同期
```csharp
// SyncController.cs - TriggerSync
var syncStatus = new SyncStatus
{
    Status = "running",  // 最初から"running"
    // ...
};
```

### 2. ソートロジックの問題

現在の`GetSyncHistory`のソートロジック：

```csharp
var history = await _context.SyncStatuses
    .Where(s => s.StoreId == currentStore.Id)
    .OrderByDescending(s => s.EndDate.HasValue ? 1 : 0)  // EndDateがあるレコードを先に
    .ThenByDescending(s => s.EndDate ?? s.StartDate)     // EndDateでソート、なければStartDateでソート
    .Take(limit)  // limit=10
    // ...
```

**問題点**:
- `OrderByDescending(s => s.EndDate.HasValue ? 1 : 0)`により、`EndDate`があるレコード（completed/failed）がすべて先に来る
- `EndDate`がないレコード（running/pending）は後ろに来る
- `limit=10`なので、completed/failedが10件以上あると、running/pendingのレコードは表示されない

### 3. 実際の動作

1. **初期同期の場合**:
   - `Status = "pending"`で作成される
   - Hangfireジョブが開始されると`Status = "running"`に更新される
   - `EndDate = null`なので、`EndDate.HasValue = false`
   - ソート順: `EndDate.HasValue ? 1 : 0 = 0` → 後ろに来る
   - **しかし、初期同期は通常すぐに`running`に更新されるため、最新の`StartDate`でソートされ、表示される可能性がある**

2. **手動同期の場合**:
   - `Status = "running"`で作成される
   - `EndDate = null`なので、`EndDate.HasValue = false`
   - ソート順: `EndDate.HasValue ? 1 : 0 = 0` → 後ろに来る
   - **completed/failedが10件以上あると、表示されない**

## 解決策

### オプション1: 実行中の同期を優先表示（推奨）

実行中の同期（`Status = "running"`または`Status = "pending"`）を優先的に表示する。

```csharp
var history = await _context.SyncStatuses
    .Where(s => s.StoreId == currentStore.Id)
    .OrderByDescending(s => s.Status == "running" || s.Status == "pending" ? 1 : 0)  // 実行中を先に
    .ThenByDescending(s => s.EndDate.HasValue ? 1 : 0)  // EndDateがあるレコードを次に
    .ThenByDescending(s => s.EndDate ?? s.StartDate)     // 日時でソート
    .Take(limit)
    // ...
```

### オプション2: 実行中の同期を別途取得

実行中の同期を別途取得して、常に表示する。

```csharp
// 実行中の同期を取得
var runningSyncs = await _context.SyncStatuses
    .Where(s => s.StoreId == currentStore.Id && (s.Status == "running" || s.Status == "pending"))
    .OrderByDescending(s => s.StartDate)
    .ToListAsync();

// 完了した同期を取得
var completedSyncs = await _context.SyncStatuses
    .Where(s => s.StoreId == currentStore.Id && s.Status != "running" && s.Status != "pending")
    .OrderByDescending(s => s.EndDate ?? s.StartDate)
    .Take(limit - runningSyncs.Count)
    .ToListAsync();

// 結合
var history = runningSyncs.Concat(completedSyncs).Take(limit);
```

### オプション3: 実行中の同期を常に表示（limitを超えても）

実行中の同期は`limit`に関係なく常に表示する。

```csharp
var runningSyncs = await _context.SyncStatuses
    .Where(s => s.StoreId == currentStore.Id && (s.Status == "running" || s.Status == "pending"))
    .OrderByDescending(s => s.StartDate)
    .ToListAsync();

var completedSyncs = await _context.SyncStatuses
    .Where(s => s.StoreId == currentStore.Id && s.Status != "running" && s.Status != "pending")
    .OrderByDescending(s => s.EndDate ?? s.StartDate)
    .Take(Math.Max(0, limit - runningSyncs.Count))
    .ToListAsync();

var history = runningSyncs.Concat(completedSyncs);
```

## 推奨実装

**オプション1**を推奨します。理由：
- 実装が簡単
- 実行中の同期が常に表示される
- 完了した同期も正しくソートされる

## 実装チェックリスト

- [ ] バックエンド: `GetSyncHistory`のソートロジックを修正
- [ ] テスト: 初期同期実行中が表示されることを確認
- [ ] テスト: 手動同期実行中が表示されることを確認
- [ ] テスト: 完了した同期が正しくソートされることを確認
- [ ] テスト: limit=10で、実行中と完了済みが混在する場合の動作確認
